// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'pin_models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$PinSetupCallerState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() settings,
    required TResult Function() pinWelcome,
    required TResult Function() newWalletPinWelcome,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? settings,
    TResult? Function()? pinWelcome,
    TResult? Function()? newWalletPinWelcome,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? settings,
    TResult Function()? pinWelcome,
    TResult Function()? newWalletPinWelcome,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupCallerStateEmpty value) empty,
    required TResult Function(PinSetupCallerStateSettings value) settings,
    required TResult Function(PinSetupCallerStatePinWelcome value) pinWelcome,
    required TResult Function(PinSetupCallerStateNewWalletPinWelcome value)
        newWalletPinWelcome,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupCallerStateEmpty value)? empty,
    TResult? Function(PinSetupCallerStateSettings value)? settings,
    TResult? Function(PinSetupCallerStatePinWelcome value)? pinWelcome,
    TResult? Function(PinSetupCallerStateNewWalletPinWelcome value)?
        newWalletPinWelcome,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupCallerStateEmpty value)? empty,
    TResult Function(PinSetupCallerStateSettings value)? settings,
    TResult Function(PinSetupCallerStatePinWelcome value)? pinWelcome,
    TResult Function(PinSetupCallerStateNewWalletPinWelcome value)?
        newWalletPinWelcome,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PinSetupCallerStateCopyWith<$Res> {
  factory $PinSetupCallerStateCopyWith(
          PinSetupCallerState value, $Res Function(PinSetupCallerState) then) =
      _$PinSetupCallerStateCopyWithImpl<$Res, PinSetupCallerState>;
}

/// @nodoc
class _$PinSetupCallerStateCopyWithImpl<$Res, $Val extends PinSetupCallerState>
    implements $PinSetupCallerStateCopyWith<$Res> {
  _$PinSetupCallerStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PinSetupCallerStateEmptyImplCopyWith<$Res> {
  factory _$$PinSetupCallerStateEmptyImplCopyWith(
          _$PinSetupCallerStateEmptyImpl value,
          $Res Function(_$PinSetupCallerStateEmptyImpl) then) =
      __$$PinSetupCallerStateEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinSetupCallerStateEmptyImplCopyWithImpl<$Res>
    extends _$PinSetupCallerStateCopyWithImpl<$Res,
        _$PinSetupCallerStateEmptyImpl>
    implements _$$PinSetupCallerStateEmptyImplCopyWith<$Res> {
  __$$PinSetupCallerStateEmptyImplCopyWithImpl(
      _$PinSetupCallerStateEmptyImpl _value,
      $Res Function(_$PinSetupCallerStateEmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinSetupCallerStateEmptyImpl implements PinSetupCallerStateEmpty {
  const _$PinSetupCallerStateEmptyImpl();

  @override
  String toString() {
    return 'PinSetupCallerState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinSetupCallerStateEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() settings,
    required TResult Function() pinWelcome,
    required TResult Function() newWalletPinWelcome,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? settings,
    TResult? Function()? pinWelcome,
    TResult? Function()? newWalletPinWelcome,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? settings,
    TResult Function()? pinWelcome,
    TResult Function()? newWalletPinWelcome,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupCallerStateEmpty value) empty,
    required TResult Function(PinSetupCallerStateSettings value) settings,
    required TResult Function(PinSetupCallerStatePinWelcome value) pinWelcome,
    required TResult Function(PinSetupCallerStateNewWalletPinWelcome value)
        newWalletPinWelcome,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupCallerStateEmpty value)? empty,
    TResult? Function(PinSetupCallerStateSettings value)? settings,
    TResult? Function(PinSetupCallerStatePinWelcome value)? pinWelcome,
    TResult? Function(PinSetupCallerStateNewWalletPinWelcome value)?
        newWalletPinWelcome,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupCallerStateEmpty value)? empty,
    TResult Function(PinSetupCallerStateSettings value)? settings,
    TResult Function(PinSetupCallerStatePinWelcome value)? pinWelcome,
    TResult Function(PinSetupCallerStateNewWalletPinWelcome value)?
        newWalletPinWelcome,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class PinSetupCallerStateEmpty implements PinSetupCallerState {
  const factory PinSetupCallerStateEmpty() = _$PinSetupCallerStateEmptyImpl;
}

/// @nodoc
abstract class _$$PinSetupCallerStateSettingsImplCopyWith<$Res> {
  factory _$$PinSetupCallerStateSettingsImplCopyWith(
          _$PinSetupCallerStateSettingsImpl value,
          $Res Function(_$PinSetupCallerStateSettingsImpl) then) =
      __$$PinSetupCallerStateSettingsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinSetupCallerStateSettingsImplCopyWithImpl<$Res>
    extends _$PinSetupCallerStateCopyWithImpl<$Res,
        _$PinSetupCallerStateSettingsImpl>
    implements _$$PinSetupCallerStateSettingsImplCopyWith<$Res> {
  __$$PinSetupCallerStateSettingsImplCopyWithImpl(
      _$PinSetupCallerStateSettingsImpl _value,
      $Res Function(_$PinSetupCallerStateSettingsImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinSetupCallerStateSettingsImpl implements PinSetupCallerStateSettings {
  const _$PinSetupCallerStateSettingsImpl();

  @override
  String toString() {
    return 'PinSetupCallerState.settings()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinSetupCallerStateSettingsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() settings,
    required TResult Function() pinWelcome,
    required TResult Function() newWalletPinWelcome,
  }) {
    return settings();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? settings,
    TResult? Function()? pinWelcome,
    TResult? Function()? newWalletPinWelcome,
  }) {
    return settings?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? settings,
    TResult Function()? pinWelcome,
    TResult Function()? newWalletPinWelcome,
    required TResult orElse(),
  }) {
    if (settings != null) {
      return settings();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupCallerStateEmpty value) empty,
    required TResult Function(PinSetupCallerStateSettings value) settings,
    required TResult Function(PinSetupCallerStatePinWelcome value) pinWelcome,
    required TResult Function(PinSetupCallerStateNewWalletPinWelcome value)
        newWalletPinWelcome,
  }) {
    return settings(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupCallerStateEmpty value)? empty,
    TResult? Function(PinSetupCallerStateSettings value)? settings,
    TResult? Function(PinSetupCallerStatePinWelcome value)? pinWelcome,
    TResult? Function(PinSetupCallerStateNewWalletPinWelcome value)?
        newWalletPinWelcome,
  }) {
    return settings?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupCallerStateEmpty value)? empty,
    TResult Function(PinSetupCallerStateSettings value)? settings,
    TResult Function(PinSetupCallerStatePinWelcome value)? pinWelcome,
    TResult Function(PinSetupCallerStateNewWalletPinWelcome value)?
        newWalletPinWelcome,
    required TResult orElse(),
  }) {
    if (settings != null) {
      return settings(this);
    }
    return orElse();
  }
}

abstract class PinSetupCallerStateSettings implements PinSetupCallerState {
  const factory PinSetupCallerStateSettings() =
      _$PinSetupCallerStateSettingsImpl;
}

/// @nodoc
abstract class _$$PinSetupCallerStatePinWelcomeImplCopyWith<$Res> {
  factory _$$PinSetupCallerStatePinWelcomeImplCopyWith(
          _$PinSetupCallerStatePinWelcomeImpl value,
          $Res Function(_$PinSetupCallerStatePinWelcomeImpl) then) =
      __$$PinSetupCallerStatePinWelcomeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinSetupCallerStatePinWelcomeImplCopyWithImpl<$Res>
    extends _$PinSetupCallerStateCopyWithImpl<$Res,
        _$PinSetupCallerStatePinWelcomeImpl>
    implements _$$PinSetupCallerStatePinWelcomeImplCopyWith<$Res> {
  __$$PinSetupCallerStatePinWelcomeImplCopyWithImpl(
      _$PinSetupCallerStatePinWelcomeImpl _value,
      $Res Function(_$PinSetupCallerStatePinWelcomeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinSetupCallerStatePinWelcomeImpl
    implements PinSetupCallerStatePinWelcome {
  const _$PinSetupCallerStatePinWelcomeImpl();

  @override
  String toString() {
    return 'PinSetupCallerState.pinWelcome()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinSetupCallerStatePinWelcomeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() settings,
    required TResult Function() pinWelcome,
    required TResult Function() newWalletPinWelcome,
  }) {
    return pinWelcome();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? settings,
    TResult? Function()? pinWelcome,
    TResult? Function()? newWalletPinWelcome,
  }) {
    return pinWelcome?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? settings,
    TResult Function()? pinWelcome,
    TResult Function()? newWalletPinWelcome,
    required TResult orElse(),
  }) {
    if (pinWelcome != null) {
      return pinWelcome();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupCallerStateEmpty value) empty,
    required TResult Function(PinSetupCallerStateSettings value) settings,
    required TResult Function(PinSetupCallerStatePinWelcome value) pinWelcome,
    required TResult Function(PinSetupCallerStateNewWalletPinWelcome value)
        newWalletPinWelcome,
  }) {
    return pinWelcome(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupCallerStateEmpty value)? empty,
    TResult? Function(PinSetupCallerStateSettings value)? settings,
    TResult? Function(PinSetupCallerStatePinWelcome value)? pinWelcome,
    TResult? Function(PinSetupCallerStateNewWalletPinWelcome value)?
        newWalletPinWelcome,
  }) {
    return pinWelcome?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupCallerStateEmpty value)? empty,
    TResult Function(PinSetupCallerStateSettings value)? settings,
    TResult Function(PinSetupCallerStatePinWelcome value)? pinWelcome,
    TResult Function(PinSetupCallerStateNewWalletPinWelcome value)?
        newWalletPinWelcome,
    required TResult orElse(),
  }) {
    if (pinWelcome != null) {
      return pinWelcome(this);
    }
    return orElse();
  }
}

abstract class PinSetupCallerStatePinWelcome implements PinSetupCallerState {
  const factory PinSetupCallerStatePinWelcome() =
      _$PinSetupCallerStatePinWelcomeImpl;
}

/// @nodoc
abstract class _$$PinSetupCallerStateNewWalletPinWelcomeImplCopyWith<$Res> {
  factory _$$PinSetupCallerStateNewWalletPinWelcomeImplCopyWith(
          _$PinSetupCallerStateNewWalletPinWelcomeImpl value,
          $Res Function(_$PinSetupCallerStateNewWalletPinWelcomeImpl) then) =
      __$$PinSetupCallerStateNewWalletPinWelcomeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinSetupCallerStateNewWalletPinWelcomeImplCopyWithImpl<$Res>
    extends _$PinSetupCallerStateCopyWithImpl<$Res,
        _$PinSetupCallerStateNewWalletPinWelcomeImpl>
    implements _$$PinSetupCallerStateNewWalletPinWelcomeImplCopyWith<$Res> {
  __$$PinSetupCallerStateNewWalletPinWelcomeImplCopyWithImpl(
      _$PinSetupCallerStateNewWalletPinWelcomeImpl _value,
      $Res Function(_$PinSetupCallerStateNewWalletPinWelcomeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinSetupCallerStateNewWalletPinWelcomeImpl
    implements PinSetupCallerStateNewWalletPinWelcome {
  const _$PinSetupCallerStateNewWalletPinWelcomeImpl();

  @override
  String toString() {
    return 'PinSetupCallerState.newWalletPinWelcome()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinSetupCallerStateNewWalletPinWelcomeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() settings,
    required TResult Function() pinWelcome,
    required TResult Function() newWalletPinWelcome,
  }) {
    return newWalletPinWelcome();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? settings,
    TResult? Function()? pinWelcome,
    TResult? Function()? newWalletPinWelcome,
  }) {
    return newWalletPinWelcome?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? settings,
    TResult Function()? pinWelcome,
    TResult Function()? newWalletPinWelcome,
    required TResult orElse(),
  }) {
    if (newWalletPinWelcome != null) {
      return newWalletPinWelcome();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupCallerStateEmpty value) empty,
    required TResult Function(PinSetupCallerStateSettings value) settings,
    required TResult Function(PinSetupCallerStatePinWelcome value) pinWelcome,
    required TResult Function(PinSetupCallerStateNewWalletPinWelcome value)
        newWalletPinWelcome,
  }) {
    return newWalletPinWelcome(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupCallerStateEmpty value)? empty,
    TResult? Function(PinSetupCallerStateSettings value)? settings,
    TResult? Function(PinSetupCallerStatePinWelcome value)? pinWelcome,
    TResult? Function(PinSetupCallerStateNewWalletPinWelcome value)?
        newWalletPinWelcome,
  }) {
    return newWalletPinWelcome?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupCallerStateEmpty value)? empty,
    TResult Function(PinSetupCallerStateSettings value)? settings,
    TResult Function(PinSetupCallerStatePinWelcome value)? pinWelcome,
    TResult Function(PinSetupCallerStateNewWalletPinWelcome value)?
        newWalletPinWelcome,
    required TResult orElse(),
  }) {
    if (newWalletPinWelcome != null) {
      return newWalletPinWelcome(this);
    }
    return orElse();
  }
}

abstract class PinSetupCallerStateNewWalletPinWelcome
    implements PinSetupCallerState {
  const factory PinSetupCallerStateNewWalletPinWelcome() =
      _$PinSetupCallerStateNewWalletPinWelcomeImpl;
}

/// @nodoc
mixin _$PinSetupExitState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() back,
    required TResult Function() success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? back,
    TResult? Function()? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? back,
    TResult Function()? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupExitStateEmpty value) empty,
    required TResult Function(PinSetupExitStateBack value) back,
    required TResult Function(PinSetupExitStateSuccess value) success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupExitStateEmpty value)? empty,
    TResult? Function(PinSetupExitStateBack value)? back,
    TResult? Function(PinSetupExitStateSuccess value)? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupExitStateEmpty value)? empty,
    TResult Function(PinSetupExitStateBack value)? back,
    TResult Function(PinSetupExitStateSuccess value)? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PinSetupExitStateCopyWith<$Res> {
  factory $PinSetupExitStateCopyWith(
          PinSetupExitState value, $Res Function(PinSetupExitState) then) =
      _$PinSetupExitStateCopyWithImpl<$Res, PinSetupExitState>;
}

/// @nodoc
class _$PinSetupExitStateCopyWithImpl<$Res, $Val extends PinSetupExitState>
    implements $PinSetupExitStateCopyWith<$Res> {
  _$PinSetupExitStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PinSetupExitStateEmptyImplCopyWith<$Res> {
  factory _$$PinSetupExitStateEmptyImplCopyWith(
          _$PinSetupExitStateEmptyImpl value,
          $Res Function(_$PinSetupExitStateEmptyImpl) then) =
      __$$PinSetupExitStateEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinSetupExitStateEmptyImplCopyWithImpl<$Res>
    extends _$PinSetupExitStateCopyWithImpl<$Res, _$PinSetupExitStateEmptyImpl>
    implements _$$PinSetupExitStateEmptyImplCopyWith<$Res> {
  __$$PinSetupExitStateEmptyImplCopyWithImpl(
      _$PinSetupExitStateEmptyImpl _value,
      $Res Function(_$PinSetupExitStateEmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinSetupExitStateEmptyImpl implements PinSetupExitStateEmpty {
  const _$PinSetupExitStateEmptyImpl();

  @override
  String toString() {
    return 'PinSetupExitState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinSetupExitStateEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() back,
    required TResult Function() success,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? back,
    TResult? Function()? success,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? back,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupExitStateEmpty value) empty,
    required TResult Function(PinSetupExitStateBack value) back,
    required TResult Function(PinSetupExitStateSuccess value) success,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupExitStateEmpty value)? empty,
    TResult? Function(PinSetupExitStateBack value)? back,
    TResult? Function(PinSetupExitStateSuccess value)? success,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupExitStateEmpty value)? empty,
    TResult Function(PinSetupExitStateBack value)? back,
    TResult Function(PinSetupExitStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class PinSetupExitStateEmpty implements PinSetupExitState {
  const factory PinSetupExitStateEmpty() = _$PinSetupExitStateEmptyImpl;
}

/// @nodoc
abstract class _$$PinSetupExitStateBackImplCopyWith<$Res> {
  factory _$$PinSetupExitStateBackImplCopyWith(
          _$PinSetupExitStateBackImpl value,
          $Res Function(_$PinSetupExitStateBackImpl) then) =
      __$$PinSetupExitStateBackImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinSetupExitStateBackImplCopyWithImpl<$Res>
    extends _$PinSetupExitStateCopyWithImpl<$Res, _$PinSetupExitStateBackImpl>
    implements _$$PinSetupExitStateBackImplCopyWith<$Res> {
  __$$PinSetupExitStateBackImplCopyWithImpl(_$PinSetupExitStateBackImpl _value,
      $Res Function(_$PinSetupExitStateBackImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinSetupExitStateBackImpl implements PinSetupExitStateBack {
  const _$PinSetupExitStateBackImpl();

  @override
  String toString() {
    return 'PinSetupExitState.back()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinSetupExitStateBackImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() back,
    required TResult Function() success,
  }) {
    return back();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? back,
    TResult? Function()? success,
  }) {
    return back?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? back,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (back != null) {
      return back();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupExitStateEmpty value) empty,
    required TResult Function(PinSetupExitStateBack value) back,
    required TResult Function(PinSetupExitStateSuccess value) success,
  }) {
    return back(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupExitStateEmpty value)? empty,
    TResult? Function(PinSetupExitStateBack value)? back,
    TResult? Function(PinSetupExitStateSuccess value)? success,
  }) {
    return back?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupExitStateEmpty value)? empty,
    TResult Function(PinSetupExitStateBack value)? back,
    TResult Function(PinSetupExitStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (back != null) {
      return back(this);
    }
    return orElse();
  }
}

abstract class PinSetupExitStateBack implements PinSetupExitState {
  const factory PinSetupExitStateBack() = _$PinSetupExitStateBackImpl;
}

/// @nodoc
abstract class _$$PinSetupExitStateSuccessImplCopyWith<$Res> {
  factory _$$PinSetupExitStateSuccessImplCopyWith(
          _$PinSetupExitStateSuccessImpl value,
          $Res Function(_$PinSetupExitStateSuccessImpl) then) =
      __$$PinSetupExitStateSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinSetupExitStateSuccessImplCopyWithImpl<$Res>
    extends _$PinSetupExitStateCopyWithImpl<$Res,
        _$PinSetupExitStateSuccessImpl>
    implements _$$PinSetupExitStateSuccessImplCopyWith<$Res> {
  __$$PinSetupExitStateSuccessImplCopyWithImpl(
      _$PinSetupExitStateSuccessImpl _value,
      $Res Function(_$PinSetupExitStateSuccessImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinSetupExitStateSuccessImpl implements PinSetupExitStateSuccess {
  const _$PinSetupExitStateSuccessImpl();

  @override
  String toString() {
    return 'PinSetupExitState.success()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinSetupExitStateSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() back,
    required TResult Function() success,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? back,
    TResult? Function()? success,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? back,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupExitStateEmpty value) empty,
    required TResult Function(PinSetupExitStateBack value) back,
    required TResult Function(PinSetupExitStateSuccess value) success,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupExitStateEmpty value)? empty,
    TResult? Function(PinSetupExitStateBack value)? back,
    TResult? Function(PinSetupExitStateSuccess value)? success,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupExitStateEmpty value)? empty,
    TResult Function(PinSetupExitStateBack value)? back,
    TResult Function(PinSetupExitStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class PinSetupExitStateSuccess implements PinSetupExitState {
  const factory PinSetupExitStateSuccess() = _$PinSetupExitStateSuccessImpl;
}

/// @nodoc
mixin _$PinFieldState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() first,
    required TResult Function() second,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? first,
    TResult? Function()? second,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? first,
    TResult Function()? second,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinFieldStateFirst value) first,
    required TResult Function(PinFieldStateSecond value) second,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinFieldStateFirst value)? first,
    TResult? Function(PinFieldStateSecond value)? second,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinFieldStateFirst value)? first,
    TResult Function(PinFieldStateSecond value)? second,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PinFieldStateCopyWith<$Res> {
  factory $PinFieldStateCopyWith(
          PinFieldState value, $Res Function(PinFieldState) then) =
      _$PinFieldStateCopyWithImpl<$Res, PinFieldState>;
}

/// @nodoc
class _$PinFieldStateCopyWithImpl<$Res, $Val extends PinFieldState>
    implements $PinFieldStateCopyWith<$Res> {
  _$PinFieldStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PinFieldStateFirstImplCopyWith<$Res> {
  factory _$$PinFieldStateFirstImplCopyWith(_$PinFieldStateFirstImpl value,
          $Res Function(_$PinFieldStateFirstImpl) then) =
      __$$PinFieldStateFirstImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinFieldStateFirstImplCopyWithImpl<$Res>
    extends _$PinFieldStateCopyWithImpl<$Res, _$PinFieldStateFirstImpl>
    implements _$$PinFieldStateFirstImplCopyWith<$Res> {
  __$$PinFieldStateFirstImplCopyWithImpl(_$PinFieldStateFirstImpl _value,
      $Res Function(_$PinFieldStateFirstImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinFieldStateFirstImpl implements PinFieldStateFirst {
  const _$PinFieldStateFirstImpl();

  @override
  String toString() {
    return 'PinFieldState.first()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PinFieldStateFirstImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() first,
    required TResult Function() second,
  }) {
    return first();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? first,
    TResult? Function()? second,
  }) {
    return first?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? first,
    TResult Function()? second,
    required TResult orElse(),
  }) {
    if (first != null) {
      return first();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinFieldStateFirst value) first,
    required TResult Function(PinFieldStateSecond value) second,
  }) {
    return first(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinFieldStateFirst value)? first,
    TResult? Function(PinFieldStateSecond value)? second,
  }) {
    return first?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinFieldStateFirst value)? first,
    TResult Function(PinFieldStateSecond value)? second,
    required TResult orElse(),
  }) {
    if (first != null) {
      return first(this);
    }
    return orElse();
  }
}

abstract class PinFieldStateFirst implements PinFieldState {
  const factory PinFieldStateFirst() = _$PinFieldStateFirstImpl;
}

/// @nodoc
abstract class _$$PinFieldStateSecondImplCopyWith<$Res> {
  factory _$$PinFieldStateSecondImplCopyWith(_$PinFieldStateSecondImpl value,
          $Res Function(_$PinFieldStateSecondImpl) then) =
      __$$PinFieldStateSecondImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinFieldStateSecondImplCopyWithImpl<$Res>
    extends _$PinFieldStateCopyWithImpl<$Res, _$PinFieldStateSecondImpl>
    implements _$$PinFieldStateSecondImplCopyWith<$Res> {
  __$$PinFieldStateSecondImplCopyWithImpl(_$PinFieldStateSecondImpl _value,
      $Res Function(_$PinFieldStateSecondImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinFieldStateSecondImpl implements PinFieldStateSecond {
  const _$PinFieldStateSecondImpl();

  @override
  String toString() {
    return 'PinFieldState.second()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinFieldStateSecondImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() first,
    required TResult Function() second,
  }) {
    return second();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? first,
    TResult? Function()? second,
  }) {
    return second?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? first,
    TResult Function()? second,
    required TResult orElse(),
  }) {
    if (second != null) {
      return second();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinFieldStateFirst value) first,
    required TResult Function(PinFieldStateSecond value) second,
  }) {
    return second(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinFieldStateFirst value)? first,
    TResult? Function(PinFieldStateSecond value)? second,
  }) {
    return second?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinFieldStateFirst value)? first,
    TResult Function(PinFieldStateSecond value)? second,
    required TResult orElse(),
  }) {
    if (second != null) {
      return second(this);
    }
    return orElse();
  }
}

abstract class PinFieldStateSecond implements PinFieldState {
  const factory PinFieldStateSecond() = _$PinFieldStateSecondImpl;
}

/// @nodoc
mixin _$PinSetupState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(String message) error,
    required TResult Function() done,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(String message)? error,
    TResult? Function()? done,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(String message)? error,
    TResult Function()? done,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupStateIdle value) idle,
    required TResult Function(PinSetupStateError value) error,
    required TResult Function(PinSetupStateDone value) done,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupStateIdle value)? idle,
    TResult? Function(PinSetupStateError value)? error,
    TResult? Function(PinSetupStateDone value)? done,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupStateIdle value)? idle,
    TResult Function(PinSetupStateError value)? error,
    TResult Function(PinSetupStateDone value)? done,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PinSetupStateCopyWith<$Res> {
  factory $PinSetupStateCopyWith(
          PinSetupState value, $Res Function(PinSetupState) then) =
      _$PinSetupStateCopyWithImpl<$Res, PinSetupState>;
}

/// @nodoc
class _$PinSetupStateCopyWithImpl<$Res, $Val extends PinSetupState>
    implements $PinSetupStateCopyWith<$Res> {
  _$PinSetupStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PinSetupStateIdleImplCopyWith<$Res> {
  factory _$$PinSetupStateIdleImplCopyWith(_$PinSetupStateIdleImpl value,
          $Res Function(_$PinSetupStateIdleImpl) then) =
      __$$PinSetupStateIdleImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinSetupStateIdleImplCopyWithImpl<$Res>
    extends _$PinSetupStateCopyWithImpl<$Res, _$PinSetupStateIdleImpl>
    implements _$$PinSetupStateIdleImplCopyWith<$Res> {
  __$$PinSetupStateIdleImplCopyWithImpl(_$PinSetupStateIdleImpl _value,
      $Res Function(_$PinSetupStateIdleImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinSetupStateIdleImpl implements PinSetupStateIdle {
  const _$PinSetupStateIdleImpl();

  @override
  String toString() {
    return 'PinSetupState.idle()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PinSetupStateIdleImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(String message) error,
    required TResult Function() done,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(String message)? error,
    TResult? Function()? done,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(String message)? error,
    TResult Function()? done,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupStateIdle value) idle,
    required TResult Function(PinSetupStateError value) error,
    required TResult Function(PinSetupStateDone value) done,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupStateIdle value)? idle,
    TResult? Function(PinSetupStateError value)? error,
    TResult? Function(PinSetupStateDone value)? done,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupStateIdle value)? idle,
    TResult Function(PinSetupStateError value)? error,
    TResult Function(PinSetupStateDone value)? done,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class PinSetupStateIdle implements PinSetupState {
  const factory PinSetupStateIdle() = _$PinSetupStateIdleImpl;
}

/// @nodoc
abstract class _$$PinSetupStateErrorImplCopyWith<$Res> {
  factory _$$PinSetupStateErrorImplCopyWith(_$PinSetupStateErrorImpl value,
          $Res Function(_$PinSetupStateErrorImpl) then) =
      __$$PinSetupStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$PinSetupStateErrorImplCopyWithImpl<$Res>
    extends _$PinSetupStateCopyWithImpl<$Res, _$PinSetupStateErrorImpl>
    implements _$$PinSetupStateErrorImplCopyWith<$Res> {
  __$$PinSetupStateErrorImplCopyWithImpl(_$PinSetupStateErrorImpl _value,
      $Res Function(_$PinSetupStateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$PinSetupStateErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PinSetupStateErrorImpl implements PinSetupStateError {
  const _$PinSetupStateErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'PinSetupState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinSetupStateErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PinSetupStateErrorImplCopyWith<_$PinSetupStateErrorImpl> get copyWith =>
      __$$PinSetupStateErrorImplCopyWithImpl<_$PinSetupStateErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(String message) error,
    required TResult Function() done,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(String message)? error,
    TResult? Function()? done,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(String message)? error,
    TResult Function()? done,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupStateIdle value) idle,
    required TResult Function(PinSetupStateError value) error,
    required TResult Function(PinSetupStateDone value) done,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupStateIdle value)? idle,
    TResult? Function(PinSetupStateError value)? error,
    TResult? Function(PinSetupStateDone value)? done,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupStateIdle value)? idle,
    TResult Function(PinSetupStateError value)? error,
    TResult Function(PinSetupStateDone value)? done,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PinSetupStateError implements PinSetupState {
  const factory PinSetupStateError({required final String message}) =
      _$PinSetupStateErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$PinSetupStateErrorImplCopyWith<_$PinSetupStateErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PinSetupStateDoneImplCopyWith<$Res> {
  factory _$$PinSetupStateDoneImplCopyWith(_$PinSetupStateDoneImpl value,
          $Res Function(_$PinSetupStateDoneImpl) then) =
      __$$PinSetupStateDoneImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinSetupStateDoneImplCopyWithImpl<$Res>
    extends _$PinSetupStateCopyWithImpl<$Res, _$PinSetupStateDoneImpl>
    implements _$$PinSetupStateDoneImplCopyWith<$Res> {
  __$$PinSetupStateDoneImplCopyWithImpl(_$PinSetupStateDoneImpl _value,
      $Res Function(_$PinSetupStateDoneImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinSetupStateDoneImpl implements PinSetupStateDone {
  const _$PinSetupStateDoneImpl();

  @override
  String toString() {
    return 'PinSetupState.done()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PinSetupStateDoneImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(String message) error,
    required TResult Function() done,
  }) {
    return done();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(String message)? error,
    TResult? Function()? done,
  }) {
    return done?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(String message)? error,
    TResult Function()? done,
    required TResult orElse(),
  }) {
    if (done != null) {
      return done();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinSetupStateIdle value) idle,
    required TResult Function(PinSetupStateError value) error,
    required TResult Function(PinSetupStateDone value) done,
  }) {
    return done(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinSetupStateIdle value)? idle,
    TResult? Function(PinSetupStateError value)? error,
    TResult? Function(PinSetupStateDone value)? done,
  }) {
    return done?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinSetupStateIdle value)? idle,
    TResult Function(PinSetupStateError value)? error,
    TResult Function(PinSetupStateDone value)? done,
    required TResult orElse(),
  }) {
    if (done != null) {
      return done(this);
    }
    return orElse();
  }
}

abstract class PinSetupStateDone implements PinSetupState {
  const factory PinSetupStateDone() = _$PinSetupStateDoneImpl;
}

PinDataState _$PinDataStateFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'empty':
      return PinDataStateEmpty.fromJson(json);
    case 'error':
      return PinDataStateError.fromJson(json);
    case 'data':
      return PinDataStateData.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'PinDataState',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$PinDataState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String message) error,
    required TResult Function(String salt, String encryptedData,
            String pinIdentifier, String hmac)
        data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String message)? error,
    TResult? Function(String salt, String encryptedData, String pinIdentifier,
            String hmac)?
        data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String message)? error,
    TResult Function(String salt, String encryptedData, String pinIdentifier,
            String hmac)?
        data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinDataStateEmpty value) empty,
    required TResult Function(PinDataStateError value) error,
    required TResult Function(PinDataStateData value) data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinDataStateEmpty value)? empty,
    TResult? Function(PinDataStateError value)? error,
    TResult? Function(PinDataStateData value)? data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinDataStateEmpty value)? empty,
    TResult Function(PinDataStateError value)? error,
    TResult Function(PinDataStateData value)? data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PinDataStateCopyWith<$Res> {
  factory $PinDataStateCopyWith(
          PinDataState value, $Res Function(PinDataState) then) =
      _$PinDataStateCopyWithImpl<$Res, PinDataState>;
}

/// @nodoc
class _$PinDataStateCopyWithImpl<$Res, $Val extends PinDataState>
    implements $PinDataStateCopyWith<$Res> {
  _$PinDataStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PinDataStateEmptyImplCopyWith<$Res> {
  factory _$$PinDataStateEmptyImplCopyWith(_$PinDataStateEmptyImpl value,
          $Res Function(_$PinDataStateEmptyImpl) then) =
      __$$PinDataStateEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinDataStateEmptyImplCopyWithImpl<$Res>
    extends _$PinDataStateCopyWithImpl<$Res, _$PinDataStateEmptyImpl>
    implements _$$PinDataStateEmptyImplCopyWith<$Res> {
  __$$PinDataStateEmptyImplCopyWithImpl(_$PinDataStateEmptyImpl _value,
      $Res Function(_$PinDataStateEmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$PinDataStateEmptyImpl implements PinDataStateEmpty {
  const _$PinDataStateEmptyImpl({final String? $type})
      : $type = $type ?? 'empty';

  factory _$PinDataStateEmptyImpl.fromJson(Map<String, dynamic> json) =>
      _$$PinDataStateEmptyImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PinDataState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PinDataStateEmptyImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String message) error,
    required TResult Function(String salt, String encryptedData,
            String pinIdentifier, String hmac)
        data,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String message)? error,
    TResult? Function(String salt, String encryptedData, String pinIdentifier,
            String hmac)?
        data,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String message)? error,
    TResult Function(String salt, String encryptedData, String pinIdentifier,
            String hmac)?
        data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinDataStateEmpty value) empty,
    required TResult Function(PinDataStateError value) error,
    required TResult Function(PinDataStateData value) data,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinDataStateEmpty value)? empty,
    TResult? Function(PinDataStateError value)? error,
    TResult? Function(PinDataStateData value)? data,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinDataStateEmpty value)? empty,
    TResult Function(PinDataStateError value)? error,
    TResult Function(PinDataStateData value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$PinDataStateEmptyImplToJson(
      this,
    );
  }
}

abstract class PinDataStateEmpty implements PinDataState {
  const factory PinDataStateEmpty() = _$PinDataStateEmptyImpl;

  factory PinDataStateEmpty.fromJson(Map<String, dynamic> json) =
      _$PinDataStateEmptyImpl.fromJson;
}

/// @nodoc
abstract class _$$PinDataStateErrorImplCopyWith<$Res> {
  factory _$$PinDataStateErrorImplCopyWith(_$PinDataStateErrorImpl value,
          $Res Function(_$PinDataStateErrorImpl) then) =
      __$$PinDataStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$PinDataStateErrorImplCopyWithImpl<$Res>
    extends _$PinDataStateCopyWithImpl<$Res, _$PinDataStateErrorImpl>
    implements _$$PinDataStateErrorImplCopyWith<$Res> {
  __$$PinDataStateErrorImplCopyWithImpl(_$PinDataStateErrorImpl _value,
      $Res Function(_$PinDataStateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$PinDataStateErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PinDataStateErrorImpl implements PinDataStateError {
  const _$PinDataStateErrorImpl({required this.message, final String? $type})
      : $type = $type ?? 'error';

  factory _$PinDataStateErrorImpl.fromJson(Map<String, dynamic> json) =>
      _$$PinDataStateErrorImplFromJson(json);

  @override
  final String message;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PinDataState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinDataStateErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PinDataStateErrorImplCopyWith<_$PinDataStateErrorImpl> get copyWith =>
      __$$PinDataStateErrorImplCopyWithImpl<_$PinDataStateErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String message) error,
    required TResult Function(String salt, String encryptedData,
            String pinIdentifier, String hmac)
        data,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String message)? error,
    TResult? Function(String salt, String encryptedData, String pinIdentifier,
            String hmac)?
        data,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String message)? error,
    TResult Function(String salt, String encryptedData, String pinIdentifier,
            String hmac)?
        data,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinDataStateEmpty value) empty,
    required TResult Function(PinDataStateError value) error,
    required TResult Function(PinDataStateData value) data,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinDataStateEmpty value)? empty,
    TResult? Function(PinDataStateError value)? error,
    TResult? Function(PinDataStateData value)? data,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinDataStateEmpty value)? empty,
    TResult Function(PinDataStateError value)? error,
    TResult Function(PinDataStateData value)? data,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$PinDataStateErrorImplToJson(
      this,
    );
  }
}

abstract class PinDataStateError implements PinDataState {
  const factory PinDataStateError({required final String message}) =
      _$PinDataStateErrorImpl;

  factory PinDataStateError.fromJson(Map<String, dynamic> json) =
      _$PinDataStateErrorImpl.fromJson;

  String get message;
  @JsonKey(ignore: true)
  _$$PinDataStateErrorImplCopyWith<_$PinDataStateErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PinDataStateDataImplCopyWith<$Res> {
  factory _$$PinDataStateDataImplCopyWith(_$PinDataStateDataImpl value,
          $Res Function(_$PinDataStateDataImpl) then) =
      __$$PinDataStateDataImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String salt, String encryptedData, String pinIdentifier, String hmac});
}

/// @nodoc
class __$$PinDataStateDataImplCopyWithImpl<$Res>
    extends _$PinDataStateCopyWithImpl<$Res, _$PinDataStateDataImpl>
    implements _$$PinDataStateDataImplCopyWith<$Res> {
  __$$PinDataStateDataImplCopyWithImpl(_$PinDataStateDataImpl _value,
      $Res Function(_$PinDataStateDataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? salt = null,
    Object? encryptedData = null,
    Object? pinIdentifier = null,
    Object? hmac = null,
  }) {
    return _then(_$PinDataStateDataImpl(
      salt: null == salt
          ? _value.salt
          : salt // ignore: cast_nullable_to_non_nullable
              as String,
      encryptedData: null == encryptedData
          ? _value.encryptedData
          : encryptedData // ignore: cast_nullable_to_non_nullable
              as String,
      pinIdentifier: null == pinIdentifier
          ? _value.pinIdentifier
          : pinIdentifier // ignore: cast_nullable_to_non_nullable
              as String,
      hmac: null == hmac
          ? _value.hmac
          : hmac // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PinDataStateDataImpl implements PinDataStateData {
  const _$PinDataStateDataImpl(
      {required this.salt,
      required this.encryptedData,
      required this.pinIdentifier,
      required this.hmac,
      final String? $type})
      : $type = $type ?? 'data';

  factory _$PinDataStateDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$PinDataStateDataImplFromJson(json);

  @override
  final String salt;
  @override
  final String encryptedData;
  @override
  final String pinIdentifier;
  @override
  final String hmac;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PinDataState.data(salt: $salt, encryptedData: $encryptedData, pinIdentifier: $pinIdentifier, hmac: $hmac)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinDataStateDataImpl &&
            (identical(other.salt, salt) || other.salt == salt) &&
            (identical(other.encryptedData, encryptedData) ||
                other.encryptedData == encryptedData) &&
            (identical(other.pinIdentifier, pinIdentifier) ||
                other.pinIdentifier == pinIdentifier) &&
            (identical(other.hmac, hmac) || other.hmac == hmac));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, salt, encryptedData, pinIdentifier, hmac);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PinDataStateDataImplCopyWith<_$PinDataStateDataImpl> get copyWith =>
      __$$PinDataStateDataImplCopyWithImpl<_$PinDataStateDataImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String message) error,
    required TResult Function(String salt, String encryptedData,
            String pinIdentifier, String hmac)
        data,
  }) {
    return data(salt, encryptedData, pinIdentifier, hmac);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String message)? error,
    TResult? Function(String salt, String encryptedData, String pinIdentifier,
            String hmac)?
        data,
  }) {
    return data?.call(salt, encryptedData, pinIdentifier, hmac);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String message)? error,
    TResult Function(String salt, String encryptedData, String pinIdentifier,
            String hmac)?
        data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(salt, encryptedData, pinIdentifier, hmac);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinDataStateEmpty value) empty,
    required TResult Function(PinDataStateError value) error,
    required TResult Function(PinDataStateData value) data,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinDataStateEmpty value)? empty,
    TResult? Function(PinDataStateError value)? error,
    TResult? Function(PinDataStateData value)? data,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinDataStateEmpty value)? empty,
    TResult Function(PinDataStateError value)? error,
    TResult Function(PinDataStateData value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$PinDataStateDataImplToJson(
      this,
    );
  }
}

abstract class PinDataStateData implements PinDataState {
  const factory PinDataStateData(
      {required final String salt,
      required final String encryptedData,
      required final String pinIdentifier,
      required final String hmac}) = _$PinDataStateDataImpl;

  factory PinDataStateData.fromJson(Map<String, dynamic> json) =
      _$PinDataStateDataImpl.fromJson;

  String get salt;
  String get encryptedData;
  String get pinIdentifier;
  String get hmac;
  @JsonKey(ignore: true)
  _$$PinDataStateDataImplCopyWith<_$PinDataStateDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PinProtectionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() waiting,
    required TResult Function(String? message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? waiting,
    TResult? Function(String? message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? waiting,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinProtectionStateIdle value) idle,
    required TResult Function(PinProtectionStateWaiting value) waiting,
    required TResult Function(PinProtectionStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinProtectionStateIdle value)? idle,
    TResult? Function(PinProtectionStateWaiting value)? waiting,
    TResult? Function(PinProtectionStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinProtectionStateIdle value)? idle,
    TResult Function(PinProtectionStateWaiting value)? waiting,
    TResult Function(PinProtectionStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PinProtectionStateCopyWith<$Res> {
  factory $PinProtectionStateCopyWith(
          PinProtectionState value, $Res Function(PinProtectionState) then) =
      _$PinProtectionStateCopyWithImpl<$Res, PinProtectionState>;
}

/// @nodoc
class _$PinProtectionStateCopyWithImpl<$Res, $Val extends PinProtectionState>
    implements $PinProtectionStateCopyWith<$Res> {
  _$PinProtectionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PinProtectionStateIdleImplCopyWith<$Res> {
  factory _$$PinProtectionStateIdleImplCopyWith(
          _$PinProtectionStateIdleImpl value,
          $Res Function(_$PinProtectionStateIdleImpl) then) =
      __$$PinProtectionStateIdleImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinProtectionStateIdleImplCopyWithImpl<$Res>
    extends _$PinProtectionStateCopyWithImpl<$Res, _$PinProtectionStateIdleImpl>
    implements _$$PinProtectionStateIdleImplCopyWith<$Res> {
  __$$PinProtectionStateIdleImplCopyWithImpl(
      _$PinProtectionStateIdleImpl _value,
      $Res Function(_$PinProtectionStateIdleImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinProtectionStateIdleImpl implements PinProtectionStateIdle {
  const _$PinProtectionStateIdleImpl();

  @override
  String toString() {
    return 'PinProtectionState.idle()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinProtectionStateIdleImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() waiting,
    required TResult Function(String? message) error,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? waiting,
    TResult? Function(String? message)? error,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? waiting,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinProtectionStateIdle value) idle,
    required TResult Function(PinProtectionStateWaiting value) waiting,
    required TResult Function(PinProtectionStateError value) error,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinProtectionStateIdle value)? idle,
    TResult? Function(PinProtectionStateWaiting value)? waiting,
    TResult? Function(PinProtectionStateError value)? error,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinProtectionStateIdle value)? idle,
    TResult Function(PinProtectionStateWaiting value)? waiting,
    TResult Function(PinProtectionStateError value)? error,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class PinProtectionStateIdle implements PinProtectionState {
  const factory PinProtectionStateIdle() = _$PinProtectionStateIdleImpl;
}

/// @nodoc
abstract class _$$PinProtectionStateWaitingImplCopyWith<$Res> {
  factory _$$PinProtectionStateWaitingImplCopyWith(
          _$PinProtectionStateWaitingImpl value,
          $Res Function(_$PinProtectionStateWaitingImpl) then) =
      __$$PinProtectionStateWaitingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinProtectionStateWaitingImplCopyWithImpl<$Res>
    extends _$PinProtectionStateCopyWithImpl<$Res,
        _$PinProtectionStateWaitingImpl>
    implements _$$PinProtectionStateWaitingImplCopyWith<$Res> {
  __$$PinProtectionStateWaitingImplCopyWithImpl(
      _$PinProtectionStateWaitingImpl _value,
      $Res Function(_$PinProtectionStateWaitingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PinProtectionStateWaitingImpl implements PinProtectionStateWaiting {
  const _$PinProtectionStateWaitingImpl();

  @override
  String toString() {
    return 'PinProtectionState.waiting()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinProtectionStateWaitingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() waiting,
    required TResult Function(String? message) error,
  }) {
    return waiting();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? waiting,
    TResult? Function(String? message)? error,
  }) {
    return waiting?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? waiting,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) {
    if (waiting != null) {
      return waiting();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinProtectionStateIdle value) idle,
    required TResult Function(PinProtectionStateWaiting value) waiting,
    required TResult Function(PinProtectionStateError value) error,
  }) {
    return waiting(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinProtectionStateIdle value)? idle,
    TResult? Function(PinProtectionStateWaiting value)? waiting,
    TResult? Function(PinProtectionStateError value)? error,
  }) {
    return waiting?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinProtectionStateIdle value)? idle,
    TResult Function(PinProtectionStateWaiting value)? waiting,
    TResult Function(PinProtectionStateError value)? error,
    required TResult orElse(),
  }) {
    if (waiting != null) {
      return waiting(this);
    }
    return orElse();
  }
}

abstract class PinProtectionStateWaiting implements PinProtectionState {
  const factory PinProtectionStateWaiting() = _$PinProtectionStateWaitingImpl;
}

/// @nodoc
abstract class _$$PinProtectionStateErrorImplCopyWith<$Res> {
  factory _$$PinProtectionStateErrorImplCopyWith(
          _$PinProtectionStateErrorImpl value,
          $Res Function(_$PinProtectionStateErrorImpl) then) =
      __$$PinProtectionStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? message});
}

/// @nodoc
class __$$PinProtectionStateErrorImplCopyWithImpl<$Res>
    extends _$PinProtectionStateCopyWithImpl<$Res,
        _$PinProtectionStateErrorImpl>
    implements _$$PinProtectionStateErrorImplCopyWith<$Res> {
  __$$PinProtectionStateErrorImplCopyWithImpl(
      _$PinProtectionStateErrorImpl _value,
      $Res Function(_$PinProtectionStateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_$PinProtectionStateErrorImpl(
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$PinProtectionStateErrorImpl implements PinProtectionStateError {
  const _$PinProtectionStateErrorImpl({this.message});

  @override
  final String? message;

  @override
  String toString() {
    return 'PinProtectionState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinProtectionStateErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PinProtectionStateErrorImplCopyWith<_$PinProtectionStateErrorImpl>
      get copyWith => __$$PinProtectionStateErrorImplCopyWithImpl<
          _$PinProtectionStateErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() waiting,
    required TResult Function(String? message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? waiting,
    TResult? Function(String? message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? waiting,
    TResult Function(String? message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinProtectionStateIdle value) idle,
    required TResult Function(PinProtectionStateWaiting value) waiting,
    required TResult Function(PinProtectionStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinProtectionStateIdle value)? idle,
    TResult? Function(PinProtectionStateWaiting value)? waiting,
    TResult? Function(PinProtectionStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinProtectionStateIdle value)? idle,
    TResult Function(PinProtectionStateWaiting value)? waiting,
    TResult Function(PinProtectionStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PinProtectionStateError implements PinProtectionState {
  const factory PinProtectionStateError({final String? message}) =
      _$PinProtectionStateErrorImpl;

  String? get message;
  @JsonKey(ignore: true)
  _$$PinProtectionStateErrorImplCopyWith<_$PinProtectionStateErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}
