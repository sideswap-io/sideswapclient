// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'swap_models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$SwapPriceSubscribeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() send,
    required TResult Function() recv,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? send,
    TResult? Function()? recv,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapPriceSubscribeStateEmpty value) empty,
    required TResult Function(SwapPriceSubscribeStateSend value) send,
    required TResult Function(SwapPriceSubscribeStateRecv value) recv,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult? Function(SwapPriceSubscribeStateSend value)? send,
    TResult? Function(SwapPriceSubscribeStateRecv value)? recv,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapPriceSubscribeStateCopyWith<$Res> {
  factory $SwapPriceSubscribeStateCopyWith(
    SwapPriceSubscribeState value,
    $Res Function(SwapPriceSubscribeState) then,
  ) = _$SwapPriceSubscribeStateCopyWithImpl<$Res, SwapPriceSubscribeState>;
}

/// @nodoc
class _$SwapPriceSubscribeStateCopyWithImpl<
  $Res,
  $Val extends SwapPriceSubscribeState
>
    implements $SwapPriceSubscribeStateCopyWith<$Res> {
  _$SwapPriceSubscribeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SwapPriceSubscribeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SwapPriceSubscribeStateEmptyImplCopyWith<$Res> {
  factory _$$SwapPriceSubscribeStateEmptyImplCopyWith(
    _$SwapPriceSubscribeStateEmptyImpl value,
    $Res Function(_$SwapPriceSubscribeStateEmptyImpl) then,
  ) = __$$SwapPriceSubscribeStateEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapPriceSubscribeStateEmptyImplCopyWithImpl<$Res>
    extends
        _$SwapPriceSubscribeStateCopyWithImpl<
          $Res,
          _$SwapPriceSubscribeStateEmptyImpl
        >
    implements _$$SwapPriceSubscribeStateEmptyImplCopyWith<$Res> {
  __$$SwapPriceSubscribeStateEmptyImplCopyWithImpl(
    _$SwapPriceSubscribeStateEmptyImpl _value,
    $Res Function(_$SwapPriceSubscribeStateEmptyImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SwapPriceSubscribeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SwapPriceSubscribeStateEmptyImpl
    implements SwapPriceSubscribeStateEmpty {
  const _$SwapPriceSubscribeStateEmptyImpl();

  @override
  String toString() {
    return 'SwapPriceSubscribeState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapPriceSubscribeStateEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() send,
    required TResult Function() recv,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? send,
    TResult? Function()? recv,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapPriceSubscribeStateEmpty value) empty,
    required TResult Function(SwapPriceSubscribeStateSend value) send,
    required TResult Function(SwapPriceSubscribeStateRecv value) recv,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult? Function(SwapPriceSubscribeStateSend value)? send,
    TResult? Function(SwapPriceSubscribeStateRecv value)? recv,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class SwapPriceSubscribeStateEmpty implements SwapPriceSubscribeState {
  const factory SwapPriceSubscribeStateEmpty() =
      _$SwapPriceSubscribeStateEmptyImpl;
}

/// @nodoc
abstract class _$$SwapPriceSubscribeStateSendImplCopyWith<$Res> {
  factory _$$SwapPriceSubscribeStateSendImplCopyWith(
    _$SwapPriceSubscribeStateSendImpl value,
    $Res Function(_$SwapPriceSubscribeStateSendImpl) then,
  ) = __$$SwapPriceSubscribeStateSendImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapPriceSubscribeStateSendImplCopyWithImpl<$Res>
    extends
        _$SwapPriceSubscribeStateCopyWithImpl<
          $Res,
          _$SwapPriceSubscribeStateSendImpl
        >
    implements _$$SwapPriceSubscribeStateSendImplCopyWith<$Res> {
  __$$SwapPriceSubscribeStateSendImplCopyWithImpl(
    _$SwapPriceSubscribeStateSendImpl _value,
    $Res Function(_$SwapPriceSubscribeStateSendImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SwapPriceSubscribeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SwapPriceSubscribeStateSendImpl implements SwapPriceSubscribeStateSend {
  const _$SwapPriceSubscribeStateSendImpl();

  @override
  String toString() {
    return 'SwapPriceSubscribeState.send()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapPriceSubscribeStateSendImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() send,
    required TResult Function() recv,
  }) {
    return send();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? send,
    TResult? Function()? recv,
  }) {
    return send?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
    required TResult orElse(),
  }) {
    if (send != null) {
      return send();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapPriceSubscribeStateEmpty value) empty,
    required TResult Function(SwapPriceSubscribeStateSend value) send,
    required TResult Function(SwapPriceSubscribeStateRecv value) recv,
  }) {
    return send(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult? Function(SwapPriceSubscribeStateSend value)? send,
    TResult? Function(SwapPriceSubscribeStateRecv value)? recv,
  }) {
    return send?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
    required TResult orElse(),
  }) {
    if (send != null) {
      return send(this);
    }
    return orElse();
  }
}

abstract class SwapPriceSubscribeStateSend implements SwapPriceSubscribeState {
  const factory SwapPriceSubscribeStateSend() =
      _$SwapPriceSubscribeStateSendImpl;
}

/// @nodoc
abstract class _$$SwapPriceSubscribeStateRecvImplCopyWith<$Res> {
  factory _$$SwapPriceSubscribeStateRecvImplCopyWith(
    _$SwapPriceSubscribeStateRecvImpl value,
    $Res Function(_$SwapPriceSubscribeStateRecvImpl) then,
  ) = __$$SwapPriceSubscribeStateRecvImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapPriceSubscribeStateRecvImplCopyWithImpl<$Res>
    extends
        _$SwapPriceSubscribeStateCopyWithImpl<
          $Res,
          _$SwapPriceSubscribeStateRecvImpl
        >
    implements _$$SwapPriceSubscribeStateRecvImplCopyWith<$Res> {
  __$$SwapPriceSubscribeStateRecvImplCopyWithImpl(
    _$SwapPriceSubscribeStateRecvImpl _value,
    $Res Function(_$SwapPriceSubscribeStateRecvImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SwapPriceSubscribeState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SwapPriceSubscribeStateRecvImpl implements SwapPriceSubscribeStateRecv {
  const _$SwapPriceSubscribeStateRecvImpl();

  @override
  String toString() {
    return 'SwapPriceSubscribeState.recv()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapPriceSubscribeStateRecvImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() send,
    required TResult Function() recv,
  }) {
    return recv();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? send,
    TResult? Function()? recv,
  }) {
    return recv?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? send,
    TResult Function()? recv,
    required TResult orElse(),
  }) {
    if (recv != null) {
      return recv();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapPriceSubscribeStateEmpty value) empty,
    required TResult Function(SwapPriceSubscribeStateSend value) send,
    required TResult Function(SwapPriceSubscribeStateRecv value) recv,
  }) {
    return recv(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult? Function(SwapPriceSubscribeStateSend value)? send,
    TResult? Function(SwapPriceSubscribeStateRecv value)? recv,
  }) {
    return recv?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapPriceSubscribeStateEmpty value)? empty,
    TResult Function(SwapPriceSubscribeStateSend value)? send,
    TResult Function(SwapPriceSubscribeStateRecv value)? recv,
    required TResult orElse(),
  }) {
    if (recv != null) {
      return recv(this);
    }
    return orElse();
  }
}

abstract class SwapPriceSubscribeStateRecv implements SwapPriceSubscribeState {
  const factory SwapPriceSubscribeStateRecv() =
      _$SwapPriceSubscribeStateRecvImpl;
}

/// @nodoc
mixin _$SwapCurrentFeeRate {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(FeeRate feeRate) data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(FeeRate feeRate)? data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(FeeRate feeRate)? data,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapCurrentFeeRateEmpty value) empty,
    required TResult Function(SwapCurrentFeeRateData value) data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult? Function(SwapCurrentFeeRateData value)? data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult Function(SwapCurrentFeeRateData value)? data,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapCurrentFeeRateCopyWith<$Res> {
  factory $SwapCurrentFeeRateCopyWith(
    SwapCurrentFeeRate value,
    $Res Function(SwapCurrentFeeRate) then,
  ) = _$SwapCurrentFeeRateCopyWithImpl<$Res, SwapCurrentFeeRate>;
}

/// @nodoc
class _$SwapCurrentFeeRateCopyWithImpl<$Res, $Val extends SwapCurrentFeeRate>
    implements $SwapCurrentFeeRateCopyWith<$Res> {
  _$SwapCurrentFeeRateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SwapCurrentFeeRate
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SwapCurrentFeeRateEmptyImplCopyWith<$Res> {
  factory _$$SwapCurrentFeeRateEmptyImplCopyWith(
    _$SwapCurrentFeeRateEmptyImpl value,
    $Res Function(_$SwapCurrentFeeRateEmptyImpl) then,
  ) = __$$SwapCurrentFeeRateEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapCurrentFeeRateEmptyImplCopyWithImpl<$Res>
    extends
        _$SwapCurrentFeeRateCopyWithImpl<$Res, _$SwapCurrentFeeRateEmptyImpl>
    implements _$$SwapCurrentFeeRateEmptyImplCopyWith<$Res> {
  __$$SwapCurrentFeeRateEmptyImplCopyWithImpl(
    _$SwapCurrentFeeRateEmptyImpl _value,
    $Res Function(_$SwapCurrentFeeRateEmptyImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SwapCurrentFeeRate
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SwapCurrentFeeRateEmptyImpl implements SwapCurrentFeeRateEmpty {
  const _$SwapCurrentFeeRateEmptyImpl();

  @override
  String toString() {
    return 'SwapCurrentFeeRate.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapCurrentFeeRateEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(FeeRate feeRate) data,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(FeeRate feeRate)? data,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(FeeRate feeRate)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapCurrentFeeRateEmpty value) empty,
    required TResult Function(SwapCurrentFeeRateData value) data,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult? Function(SwapCurrentFeeRateData value)? data,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult Function(SwapCurrentFeeRateData value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class SwapCurrentFeeRateEmpty implements SwapCurrentFeeRate {
  const factory SwapCurrentFeeRateEmpty() = _$SwapCurrentFeeRateEmptyImpl;
}

/// @nodoc
abstract class _$$SwapCurrentFeeRateDataImplCopyWith<$Res> {
  factory _$$SwapCurrentFeeRateDataImplCopyWith(
    _$SwapCurrentFeeRateDataImpl value,
    $Res Function(_$SwapCurrentFeeRateDataImpl) then,
  ) = __$$SwapCurrentFeeRateDataImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FeeRate feeRate});
}

/// @nodoc
class __$$SwapCurrentFeeRateDataImplCopyWithImpl<$Res>
    extends _$SwapCurrentFeeRateCopyWithImpl<$Res, _$SwapCurrentFeeRateDataImpl>
    implements _$$SwapCurrentFeeRateDataImplCopyWith<$Res> {
  __$$SwapCurrentFeeRateDataImplCopyWithImpl(
    _$SwapCurrentFeeRateDataImpl _value,
    $Res Function(_$SwapCurrentFeeRateDataImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SwapCurrentFeeRate
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? feeRate = null}) {
    return _then(
      _$SwapCurrentFeeRateDataImpl(
        feeRate:
            null == feeRate
                ? _value.feeRate
                : feeRate // ignore: cast_nullable_to_non_nullable
                    as FeeRate,
      ),
    );
  }
}

/// @nodoc

class _$SwapCurrentFeeRateDataImpl implements SwapCurrentFeeRateData {
  const _$SwapCurrentFeeRateDataImpl({required this.feeRate});

  @override
  final FeeRate feeRate;

  @override
  String toString() {
    return 'SwapCurrentFeeRate.data(feeRate: $feeRate)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapCurrentFeeRateDataImpl &&
            (identical(other.feeRate, feeRate) || other.feeRate == feeRate));
  }

  @override
  int get hashCode => Object.hash(runtimeType, feeRate);

  /// Create a copy of SwapCurrentFeeRate
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SwapCurrentFeeRateDataImplCopyWith<_$SwapCurrentFeeRateDataImpl>
  get copyWith =>
      __$$SwapCurrentFeeRateDataImplCopyWithImpl<_$SwapCurrentFeeRateDataImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(FeeRate feeRate) data,
  }) {
    return data(feeRate);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(FeeRate feeRate)? data,
  }) {
    return data?.call(feeRate);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(FeeRate feeRate)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(feeRate);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapCurrentFeeRateEmpty value) empty,
    required TResult Function(SwapCurrentFeeRateData value) data,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult? Function(SwapCurrentFeeRateData value)? data,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapCurrentFeeRateEmpty value)? empty,
    TResult Function(SwapCurrentFeeRateData value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class SwapCurrentFeeRateData implements SwapCurrentFeeRate {
  const factory SwapCurrentFeeRateData({required final FeeRate feeRate}) =
      _$SwapCurrentFeeRateDataImpl;

  FeeRate get feeRate;

  /// Create a copy of SwapCurrentFeeRate
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SwapCurrentFeeRateDataImplCopyWith<_$SwapCurrentFeeRateDataImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SwapRecvAmountPriceStream {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String value)? data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapRecvAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapRecvAmountPriceStreamData value) data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult? Function(SwapRecvAmountPriceStreamData value)? data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapRecvAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapRecvAmountPriceStreamCopyWith<$Res> {
  factory $SwapRecvAmountPriceStreamCopyWith(
    SwapRecvAmountPriceStream value,
    $Res Function(SwapRecvAmountPriceStream) then,
  ) = _$SwapRecvAmountPriceStreamCopyWithImpl<$Res, SwapRecvAmountPriceStream>;
}

/// @nodoc
class _$SwapRecvAmountPriceStreamCopyWithImpl<
  $Res,
  $Val extends SwapRecvAmountPriceStream
>
    implements $SwapRecvAmountPriceStreamCopyWith<$Res> {
  _$SwapRecvAmountPriceStreamCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SwapRecvAmountPriceStream
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SwapRecvAmountPriceStreamEmptyImplCopyWith<$Res> {
  factory _$$SwapRecvAmountPriceStreamEmptyImplCopyWith(
    _$SwapRecvAmountPriceStreamEmptyImpl value,
    $Res Function(_$SwapRecvAmountPriceStreamEmptyImpl) then,
  ) = __$$SwapRecvAmountPriceStreamEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapRecvAmountPriceStreamEmptyImplCopyWithImpl<$Res>
    extends
        _$SwapRecvAmountPriceStreamCopyWithImpl<
          $Res,
          _$SwapRecvAmountPriceStreamEmptyImpl
        >
    implements _$$SwapRecvAmountPriceStreamEmptyImplCopyWith<$Res> {
  __$$SwapRecvAmountPriceStreamEmptyImplCopyWithImpl(
    _$SwapRecvAmountPriceStreamEmptyImpl _value,
    $Res Function(_$SwapRecvAmountPriceStreamEmptyImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SwapRecvAmountPriceStream
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SwapRecvAmountPriceStreamEmptyImpl
    implements SwapRecvAmountPriceStreamEmpty {
  const _$SwapRecvAmountPriceStreamEmptyImpl();

  @override
  String toString() {
    return 'SwapRecvAmountPriceStream.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapRecvAmountPriceStreamEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String value)? data,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapRecvAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapRecvAmountPriceStreamData value) data,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult? Function(SwapRecvAmountPriceStreamData value)? data,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapRecvAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class SwapRecvAmountPriceStreamEmpty
    implements SwapRecvAmountPriceStream {
  const factory SwapRecvAmountPriceStreamEmpty() =
      _$SwapRecvAmountPriceStreamEmptyImpl;
}

/// @nodoc
abstract class _$$SwapRecvAmountPriceStreamDataImplCopyWith<$Res> {
  factory _$$SwapRecvAmountPriceStreamDataImplCopyWith(
    _$SwapRecvAmountPriceStreamDataImpl value,
    $Res Function(_$SwapRecvAmountPriceStreamDataImpl) then,
  ) = __$$SwapRecvAmountPriceStreamDataImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$SwapRecvAmountPriceStreamDataImplCopyWithImpl<$Res>
    extends
        _$SwapRecvAmountPriceStreamCopyWithImpl<
          $Res,
          _$SwapRecvAmountPriceStreamDataImpl
        >
    implements _$$SwapRecvAmountPriceStreamDataImplCopyWith<$Res> {
  __$$SwapRecvAmountPriceStreamDataImplCopyWithImpl(
    _$SwapRecvAmountPriceStreamDataImpl _value,
    $Res Function(_$SwapRecvAmountPriceStreamDataImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SwapRecvAmountPriceStream
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? value = null}) {
    return _then(
      _$SwapRecvAmountPriceStreamDataImpl(
        value:
            null == value
                ? _value.value
                : value // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc

class _$SwapRecvAmountPriceStreamDataImpl
    implements SwapRecvAmountPriceStreamData {
  const _$SwapRecvAmountPriceStreamDataImpl({required this.value});

  @override
  final String value;

  @override
  String toString() {
    return 'SwapRecvAmountPriceStream.data(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapRecvAmountPriceStreamDataImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of SwapRecvAmountPriceStream
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SwapRecvAmountPriceStreamDataImplCopyWith<
    _$SwapRecvAmountPriceStreamDataImpl
  >
  get copyWith => __$$SwapRecvAmountPriceStreamDataImplCopyWithImpl<
    _$SwapRecvAmountPriceStreamDataImpl
  >(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) {
    return data(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String value)? data,
  }) {
    return data?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapRecvAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapRecvAmountPriceStreamData value) data,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult? Function(SwapRecvAmountPriceStreamData value)? data,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapRecvAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapRecvAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class SwapRecvAmountPriceStreamData
    implements SwapRecvAmountPriceStream {
  const factory SwapRecvAmountPriceStreamData({required final String value}) =
      _$SwapRecvAmountPriceStreamDataImpl;

  String get value;

  /// Create a copy of SwapRecvAmountPriceStream
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SwapRecvAmountPriceStreamDataImplCopyWith<
    _$SwapRecvAmountPriceStreamDataImpl
  >
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SwapSendAmountPriceStream {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String value)? data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapSendAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapSendAmountPriceStreamData value) data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult? Function(SwapSendAmountPriceStreamData value)? data,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapSendAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapSendAmountPriceStreamCopyWith<$Res> {
  factory $SwapSendAmountPriceStreamCopyWith(
    SwapSendAmountPriceStream value,
    $Res Function(SwapSendAmountPriceStream) then,
  ) = _$SwapSendAmountPriceStreamCopyWithImpl<$Res, SwapSendAmountPriceStream>;
}

/// @nodoc
class _$SwapSendAmountPriceStreamCopyWithImpl<
  $Res,
  $Val extends SwapSendAmountPriceStream
>
    implements $SwapSendAmountPriceStreamCopyWith<$Res> {
  _$SwapSendAmountPriceStreamCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SwapSendAmountPriceStream
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SwapSendAmountPriceStreamEmptyImplCopyWith<$Res> {
  factory _$$SwapSendAmountPriceStreamEmptyImplCopyWith(
    _$SwapSendAmountPriceStreamEmptyImpl value,
    $Res Function(_$SwapSendAmountPriceStreamEmptyImpl) then,
  ) = __$$SwapSendAmountPriceStreamEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SwapSendAmountPriceStreamEmptyImplCopyWithImpl<$Res>
    extends
        _$SwapSendAmountPriceStreamCopyWithImpl<
          $Res,
          _$SwapSendAmountPriceStreamEmptyImpl
        >
    implements _$$SwapSendAmountPriceStreamEmptyImplCopyWith<$Res> {
  __$$SwapSendAmountPriceStreamEmptyImplCopyWithImpl(
    _$SwapSendAmountPriceStreamEmptyImpl _value,
    $Res Function(_$SwapSendAmountPriceStreamEmptyImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SwapSendAmountPriceStream
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SwapSendAmountPriceStreamEmptyImpl
    implements SwapSendAmountPriceStreamEmpty {
  const _$SwapSendAmountPriceStreamEmptyImpl();

  @override
  String toString() {
    return 'SwapSendAmountPriceStream.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapSendAmountPriceStreamEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String value)? data,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapSendAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapSendAmountPriceStreamData value) data,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult? Function(SwapSendAmountPriceStreamData value)? data,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapSendAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class SwapSendAmountPriceStreamEmpty
    implements SwapSendAmountPriceStream {
  const factory SwapSendAmountPriceStreamEmpty() =
      _$SwapSendAmountPriceStreamEmptyImpl;
}

/// @nodoc
abstract class _$$SwapSendAmountPriceStreamDataImplCopyWith<$Res> {
  factory _$$SwapSendAmountPriceStreamDataImplCopyWith(
    _$SwapSendAmountPriceStreamDataImpl value,
    $Res Function(_$SwapSendAmountPriceStreamDataImpl) then,
  ) = __$$SwapSendAmountPriceStreamDataImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$SwapSendAmountPriceStreamDataImplCopyWithImpl<$Res>
    extends
        _$SwapSendAmountPriceStreamCopyWithImpl<
          $Res,
          _$SwapSendAmountPriceStreamDataImpl
        >
    implements _$$SwapSendAmountPriceStreamDataImplCopyWith<$Res> {
  __$$SwapSendAmountPriceStreamDataImplCopyWithImpl(
    _$SwapSendAmountPriceStreamDataImpl _value,
    $Res Function(_$SwapSendAmountPriceStreamDataImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SwapSendAmountPriceStream
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? value = null}) {
    return _then(
      _$SwapSendAmountPriceStreamDataImpl(
        value:
            null == value
                ? _value.value
                : value // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc

class _$SwapSendAmountPriceStreamDataImpl
    implements SwapSendAmountPriceStreamData {
  const _$SwapSendAmountPriceStreamDataImpl({required this.value});

  @override
  final String value;

  @override
  String toString() {
    return 'SwapSendAmountPriceStream.data(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapSendAmountPriceStreamDataImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of SwapSendAmountPriceStream
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SwapSendAmountPriceStreamDataImplCopyWith<
    _$SwapSendAmountPriceStreamDataImpl
  >
  get copyWith => __$$SwapSendAmountPriceStreamDataImplCopyWithImpl<
    _$SwapSendAmountPriceStreamDataImpl
  >(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(String value) data,
  }) {
    return data(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(String value)? data,
  }) {
    return data?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(String value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SwapSendAmountPriceStreamEmpty value) empty,
    required TResult Function(SwapSendAmountPriceStreamData value) data,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult? Function(SwapSendAmountPriceStreamData value)? data,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SwapSendAmountPriceStreamEmpty value)? empty,
    TResult Function(SwapSendAmountPriceStreamData value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class SwapSendAmountPriceStreamData
    implements SwapSendAmountPriceStream {
  const factory SwapSendAmountPriceStreamData({required final String value}) =
      _$SwapSendAmountPriceStreamDataImpl;

  String get value;

  /// Create a copy of SwapSendAmountPriceStream
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SwapSendAmountPriceStreamDataImplCopyWith<
    _$SwapSendAmountPriceStreamDataImpl
  >
  get copyWith => throw _privateConstructorUsedError;
}
