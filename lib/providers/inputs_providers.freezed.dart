// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'inputs_providers.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$InputsWalletTypeFlag {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() regular,
    required TResult Function() amp,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? regular,
    TResult? Function()? amp,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? regular,
    TResult Function()? amp,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InputsWalletTypeFlagRegular value) regular,
    required TResult Function(InputsWalletTypeFlagAmp value) amp,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InputsWalletTypeFlagRegular value)? regular,
    TResult? Function(InputsWalletTypeFlagAmp value)? amp,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InputsWalletTypeFlagRegular value)? regular,
    TResult Function(InputsWalletTypeFlagAmp value)? amp,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InputsWalletTypeFlagCopyWith<$Res> {
  factory $InputsWalletTypeFlagCopyWith(
    InputsWalletTypeFlag value,
    $Res Function(InputsWalletTypeFlag) then,
  ) = _$InputsWalletTypeFlagCopyWithImpl<$Res, InputsWalletTypeFlag>;
}

/// @nodoc
class _$InputsWalletTypeFlagCopyWithImpl<
  $Res,
  $Val extends InputsWalletTypeFlag
>
    implements $InputsWalletTypeFlagCopyWith<$Res> {
  _$InputsWalletTypeFlagCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of InputsWalletTypeFlag
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InputsWalletTypeFlagRegularImplCopyWith<$Res> {
  factory _$$InputsWalletTypeFlagRegularImplCopyWith(
    _$InputsWalletTypeFlagRegularImpl value,
    $Res Function(_$InputsWalletTypeFlagRegularImpl) then,
  ) = __$$InputsWalletTypeFlagRegularImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InputsWalletTypeFlagRegularImplCopyWithImpl<$Res>
    extends
        _$InputsWalletTypeFlagCopyWithImpl<
          $Res,
          _$InputsWalletTypeFlagRegularImpl
        >
    implements _$$InputsWalletTypeFlagRegularImplCopyWith<$Res> {
  __$$InputsWalletTypeFlagRegularImplCopyWithImpl(
    _$InputsWalletTypeFlagRegularImpl _value,
    $Res Function(_$InputsWalletTypeFlagRegularImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of InputsWalletTypeFlag
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InputsWalletTypeFlagRegularImpl implements InputsWalletTypeFlagRegular {
  const _$InputsWalletTypeFlagRegularImpl();

  @override
  String toString() {
    return 'InputsWalletTypeFlag.regular()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InputsWalletTypeFlagRegularImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() regular,
    required TResult Function() amp,
  }) {
    return regular();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? regular,
    TResult? Function()? amp,
  }) {
    return regular?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? regular,
    TResult Function()? amp,
    required TResult orElse(),
  }) {
    if (regular != null) {
      return regular();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InputsWalletTypeFlagRegular value) regular,
    required TResult Function(InputsWalletTypeFlagAmp value) amp,
  }) {
    return regular(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InputsWalletTypeFlagRegular value)? regular,
    TResult? Function(InputsWalletTypeFlagAmp value)? amp,
  }) {
    return regular?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InputsWalletTypeFlagRegular value)? regular,
    TResult Function(InputsWalletTypeFlagAmp value)? amp,
    required TResult orElse(),
  }) {
    if (regular != null) {
      return regular(this);
    }
    return orElse();
  }
}

abstract class InputsWalletTypeFlagRegular implements InputsWalletTypeFlag {
  const factory InputsWalletTypeFlagRegular() =
      _$InputsWalletTypeFlagRegularImpl;
}

/// @nodoc
abstract class _$$InputsWalletTypeFlagAmpImplCopyWith<$Res> {
  factory _$$InputsWalletTypeFlagAmpImplCopyWith(
    _$InputsWalletTypeFlagAmpImpl value,
    $Res Function(_$InputsWalletTypeFlagAmpImpl) then,
  ) = __$$InputsWalletTypeFlagAmpImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InputsWalletTypeFlagAmpImplCopyWithImpl<$Res>
    extends
        _$InputsWalletTypeFlagCopyWithImpl<$Res, _$InputsWalletTypeFlagAmpImpl>
    implements _$$InputsWalletTypeFlagAmpImplCopyWith<$Res> {
  __$$InputsWalletTypeFlagAmpImplCopyWithImpl(
    _$InputsWalletTypeFlagAmpImpl _value,
    $Res Function(_$InputsWalletTypeFlagAmpImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of InputsWalletTypeFlag
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InputsWalletTypeFlagAmpImpl implements InputsWalletTypeFlagAmp {
  const _$InputsWalletTypeFlagAmpImpl();

  @override
  String toString() {
    return 'InputsWalletTypeFlag.amp()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InputsWalletTypeFlagAmpImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() regular,
    required TResult Function() amp,
  }) {
    return amp();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? regular,
    TResult? Function()? amp,
  }) {
    return amp?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? regular,
    TResult Function()? amp,
    required TResult orElse(),
  }) {
    if (amp != null) {
      return amp();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InputsWalletTypeFlagRegular value) regular,
    required TResult Function(InputsWalletTypeFlagAmp value) amp,
  }) {
    return amp(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InputsWalletTypeFlagRegular value)? regular,
    TResult? Function(InputsWalletTypeFlagAmp value)? amp,
  }) {
    return amp?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InputsWalletTypeFlagRegular value)? regular,
    TResult Function(InputsWalletTypeFlagAmp value)? amp,
    required TResult orElse(),
  }) {
    if (amp != null) {
      return amp(this);
    }
    return orElse();
  }
}

abstract class InputsWalletTypeFlagAmp implements InputsWalletTypeFlag {
  const factory InputsWalletTypeFlagAmp() = _$InputsWalletTypeFlagAmpImpl;
}

/// @nodoc
mixin _$InputsTxItem {
  String? get tx => throw _privateConstructorUsedError;
  int? get satoshi => throw _privateConstructorUsedError;

  /// Create a copy of InputsTxItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $InputsTxItemCopyWith<InputsTxItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InputsTxItemCopyWith<$Res> {
  factory $InputsTxItemCopyWith(
    InputsTxItem value,
    $Res Function(InputsTxItem) then,
  ) = _$InputsTxItemCopyWithImpl<$Res, InputsTxItem>;
  @useResult
  $Res call({String? tx, int? satoshi});
}

/// @nodoc
class _$InputsTxItemCopyWithImpl<$Res, $Val extends InputsTxItem>
    implements $InputsTxItemCopyWith<$Res> {
  _$InputsTxItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of InputsTxItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? tx = freezed, Object? satoshi = freezed}) {
    return _then(
      _value.copyWith(
            tx:
                freezed == tx
                    ? _value.tx
                    : tx // ignore: cast_nullable_to_non_nullable
                        as String?,
            satoshi:
                freezed == satoshi
                    ? _value.satoshi
                    : satoshi // ignore: cast_nullable_to_non_nullable
                        as int?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$InputsTxItemImplCopyWith<$Res>
    implements $InputsTxItemCopyWith<$Res> {
  factory _$$InputsTxItemImplCopyWith(
    _$InputsTxItemImpl value,
    $Res Function(_$InputsTxItemImpl) then,
  ) = __$$InputsTxItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? tx, int? satoshi});
}

/// @nodoc
class __$$InputsTxItemImplCopyWithImpl<$Res>
    extends _$InputsTxItemCopyWithImpl<$Res, _$InputsTxItemImpl>
    implements _$$InputsTxItemImplCopyWith<$Res> {
  __$$InputsTxItemImplCopyWithImpl(
    _$InputsTxItemImpl _value,
    $Res Function(_$InputsTxItemImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of InputsTxItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? tx = freezed, Object? satoshi = freezed}) {
    return _then(
      _$InputsTxItemImpl(
        tx:
            freezed == tx
                ? _value.tx
                : tx // ignore: cast_nullable_to_non_nullable
                    as String?,
        satoshi:
            freezed == satoshi
                ? _value.satoshi
                : satoshi // ignore: cast_nullable_to_non_nullable
                    as int?,
      ),
    );
  }
}

/// @nodoc

class _$InputsTxItemImpl implements _InputsTxItem {
  const _$InputsTxItemImpl({this.tx, this.satoshi});

  @override
  final String? tx;
  @override
  final int? satoshi;

  @override
  String toString() {
    return 'InputsTxItem(tx: $tx, satoshi: $satoshi)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InputsTxItemImpl &&
            (identical(other.tx, tx) || other.tx == tx) &&
            (identical(other.satoshi, satoshi) || other.satoshi == satoshi));
  }

  @override
  int get hashCode => Object.hash(runtimeType, tx, satoshi);

  /// Create a copy of InputsTxItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InputsTxItemImplCopyWith<_$InputsTxItemImpl> get copyWith =>
      __$$InputsTxItemImplCopyWithImpl<_$InputsTxItemImpl>(this, _$identity);
}

abstract class _InputsTxItem implements InputsTxItem {
  const factory _InputsTxItem({final String? tx, final int? satoshi}) =
      _$InputsTxItemImpl;

  @override
  String? get tx;
  @override
  int? get satoshi;

  /// Create a copy of InputsTxItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InputsTxItemImplCopyWith<_$InputsTxItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$InputsAddressItem {
  String? get address => throw _privateConstructorUsedError;
  int? get txAmount => throw _privateConstructorUsedError;
  String? get comment => throw _privateConstructorUsedError;
  int? get satoshi => throw _privateConstructorUsedError;
  List<InputsTxItem>? get inputsTx => throw _privateConstructorUsedError;

  /// Create a copy of InputsAddressItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $InputsAddressItemCopyWith<InputsAddressItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InputsAddressItemCopyWith<$Res> {
  factory $InputsAddressItemCopyWith(
    InputsAddressItem value,
    $Res Function(InputsAddressItem) then,
  ) = _$InputsAddressItemCopyWithImpl<$Res, InputsAddressItem>;
  @useResult
  $Res call({
    String? address,
    int? txAmount,
    String? comment,
    int? satoshi,
    List<InputsTxItem>? inputsTx,
  });
}

/// @nodoc
class _$InputsAddressItemCopyWithImpl<$Res, $Val extends InputsAddressItem>
    implements $InputsAddressItemCopyWith<$Res> {
  _$InputsAddressItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of InputsAddressItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address = freezed,
    Object? txAmount = freezed,
    Object? comment = freezed,
    Object? satoshi = freezed,
    Object? inputsTx = freezed,
  }) {
    return _then(
      _value.copyWith(
            address:
                freezed == address
                    ? _value.address
                    : address // ignore: cast_nullable_to_non_nullable
                        as String?,
            txAmount:
                freezed == txAmount
                    ? _value.txAmount
                    : txAmount // ignore: cast_nullable_to_non_nullable
                        as int?,
            comment:
                freezed == comment
                    ? _value.comment
                    : comment // ignore: cast_nullable_to_non_nullable
                        as String?,
            satoshi:
                freezed == satoshi
                    ? _value.satoshi
                    : satoshi // ignore: cast_nullable_to_non_nullable
                        as int?,
            inputsTx:
                freezed == inputsTx
                    ? _value.inputsTx
                    : inputsTx // ignore: cast_nullable_to_non_nullable
                        as List<InputsTxItem>?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$InputsAddressItemImplCopyWith<$Res>
    implements $InputsAddressItemCopyWith<$Res> {
  factory _$$InputsAddressItemImplCopyWith(
    _$InputsAddressItemImpl value,
    $Res Function(_$InputsAddressItemImpl) then,
  ) = __$$InputsAddressItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String? address,
    int? txAmount,
    String? comment,
    int? satoshi,
    List<InputsTxItem>? inputsTx,
  });
}

/// @nodoc
class __$$InputsAddressItemImplCopyWithImpl<$Res>
    extends _$InputsAddressItemCopyWithImpl<$Res, _$InputsAddressItemImpl>
    implements _$$InputsAddressItemImplCopyWith<$Res> {
  __$$InputsAddressItemImplCopyWithImpl(
    _$InputsAddressItemImpl _value,
    $Res Function(_$InputsAddressItemImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of InputsAddressItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address = freezed,
    Object? txAmount = freezed,
    Object? comment = freezed,
    Object? satoshi = freezed,
    Object? inputsTx = freezed,
  }) {
    return _then(
      _$InputsAddressItemImpl(
        address:
            freezed == address
                ? _value.address
                : address // ignore: cast_nullable_to_non_nullable
                    as String?,
        txAmount:
            freezed == txAmount
                ? _value.txAmount
                : txAmount // ignore: cast_nullable_to_non_nullable
                    as int?,
        comment:
            freezed == comment
                ? _value.comment
                : comment // ignore: cast_nullable_to_non_nullable
                    as String?,
        satoshi:
            freezed == satoshi
                ? _value.satoshi
                : satoshi // ignore: cast_nullable_to_non_nullable
                    as int?,
        inputsTx:
            freezed == inputsTx
                ? _value._inputsTx
                : inputsTx // ignore: cast_nullable_to_non_nullable
                    as List<InputsTxItem>?,
      ),
    );
  }
}

/// @nodoc

class _$InputsAddressItemImpl implements _InputsAddressItem {
  const _$InputsAddressItemImpl({
    this.address,
    this.txAmount,
    this.comment,
    this.satoshi,
    final List<InputsTxItem>? inputsTx,
  }) : _inputsTx = inputsTx;

  @override
  final String? address;
  @override
  final int? txAmount;
  @override
  final String? comment;
  @override
  final int? satoshi;
  final List<InputsTxItem>? _inputsTx;
  @override
  List<InputsTxItem>? get inputsTx {
    final value = _inputsTx;
    if (value == null) return null;
    if (_inputsTx is EqualUnmodifiableListView) return _inputsTx;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'InputsAddressItem(address: $address, txAmount: $txAmount, comment: $comment, satoshi: $satoshi, inputsTx: $inputsTx)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InputsAddressItemImpl &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.txAmount, txAmount) ||
                other.txAmount == txAmount) &&
            (identical(other.comment, comment) || other.comment == comment) &&
            (identical(other.satoshi, satoshi) || other.satoshi == satoshi) &&
            const DeepCollectionEquality().equals(other._inputsTx, _inputsTx));
  }

  @override
  int get hashCode => Object.hash(
    runtimeType,
    address,
    txAmount,
    comment,
    satoshi,
    const DeepCollectionEquality().hash(_inputsTx),
  );

  /// Create a copy of InputsAddressItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InputsAddressItemImplCopyWith<_$InputsAddressItemImpl> get copyWith =>
      __$$InputsAddressItemImplCopyWithImpl<_$InputsAddressItemImpl>(
        this,
        _$identity,
      );
}

abstract class _InputsAddressItem implements InputsAddressItem {
  const factory _InputsAddressItem({
    final String? address,
    final int? txAmount,
    final String? comment,
    final int? satoshi,
    final List<InputsTxItem>? inputsTx,
  }) = _$InputsAddressItemImpl;

  @override
  String? get address;
  @override
  int? get txAmount;
  @override
  String? get comment;
  @override
  int? get satoshi;
  @override
  List<InputsTxItem>? get inputsTx;

  /// Create a copy of InputsAddressItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InputsAddressItemImplCopyWith<_$InputsAddressItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$InputsItem {
  List<InputsAddressItem>? get inputs => throw _privateConstructorUsedError;

  /// Create a copy of InputsItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $InputsItemCopyWith<InputsItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InputsItemCopyWith<$Res> {
  factory $InputsItemCopyWith(
    InputsItem value,
    $Res Function(InputsItem) then,
  ) = _$InputsItemCopyWithImpl<$Res, InputsItem>;
  @useResult
  $Res call({List<InputsAddressItem>? inputs});
}

/// @nodoc
class _$InputsItemCopyWithImpl<$Res, $Val extends InputsItem>
    implements $InputsItemCopyWith<$Res> {
  _$InputsItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of InputsItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? inputs = freezed}) {
    return _then(
      _value.copyWith(
            inputs:
                freezed == inputs
                    ? _value.inputs
                    : inputs // ignore: cast_nullable_to_non_nullable
                        as List<InputsAddressItem>?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$InputsItemImplCopyWith<$Res>
    implements $InputsItemCopyWith<$Res> {
  factory _$$InputsItemImplCopyWith(
    _$InputsItemImpl value,
    $Res Function(_$InputsItemImpl) then,
  ) = __$$InputsItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<InputsAddressItem>? inputs});
}

/// @nodoc
class __$$InputsItemImplCopyWithImpl<$Res>
    extends _$InputsItemCopyWithImpl<$Res, _$InputsItemImpl>
    implements _$$InputsItemImplCopyWith<$Res> {
  __$$InputsItemImplCopyWithImpl(
    _$InputsItemImpl _value,
    $Res Function(_$InputsItemImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of InputsItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? inputs = freezed}) {
    return _then(
      _$InputsItemImpl(
        inputs:
            freezed == inputs
                ? _value._inputs
                : inputs // ignore: cast_nullable_to_non_nullable
                    as List<InputsAddressItem>?,
      ),
    );
  }
}

/// @nodoc

class _$InputsItemImpl implements _InputsItem {
  const _$InputsItemImpl({final List<InputsAddressItem>? inputs})
    : _inputs = inputs;

  final List<InputsAddressItem>? _inputs;
  @override
  List<InputsAddressItem>? get inputs {
    final value = _inputs;
    if (value == null) return null;
    if (_inputs is EqualUnmodifiableListView) return _inputs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'InputsItem(inputs: $inputs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InputsItemImpl &&
            const DeepCollectionEquality().equals(other._inputs, _inputs));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_inputs));

  /// Create a copy of InputsItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InputsItemImplCopyWith<_$InputsItemImpl> get copyWith =>
      __$$InputsItemImplCopyWithImpl<_$InputsItemImpl>(this, _$identity);
}

abstract class _InputsItem implements InputsItem {
  const factory _InputsItem({final List<InputsAddressItem>? inputs}) =
      _$InputsItemImpl;

  @override
  List<InputsAddressItem>? get inputs;

  /// Create a copy of InputsItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InputsItemImplCopyWith<_$InputsItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
