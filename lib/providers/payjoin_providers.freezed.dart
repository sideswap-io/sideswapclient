// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'payjoin_providers.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$PayjoinState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(CreatePayjoin createPayjoin) createPayjoin,
    required TResult Function() waitingCreatedPayjoin,
    required TResult Function(CreatedPayjoin createdPayjoin) createdPayjoin,
    required TResult Function() waitingSendPayjoin,
    required TResult Function(String? errorMsg) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult? Function()? waitingCreatedPayjoin,
    TResult? Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult? Function()? waitingSendPayjoin,
    TResult? Function(String? errorMsg)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult Function()? waitingCreatedPayjoin,
    TResult Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult Function()? waitingSendPayjoin,
    TResult Function(String? errorMsg)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PayjoinStateEmpty value) empty,
    required TResult Function(PayjoinStateCreatePayjoin value) createPayjoin,
    required TResult Function(PayjoinStateWaitingCreatedPayjoin value)
        waitingCreatedPayjoin,
    required TResult Function(PayjoinStateCreatedPayjoin value) createdPayjoin,
    required TResult Function(PayjoinStateWaitingSendPayjoin value)
        waitingSendPayjoin,
    required TResult Function(PayjoinStateError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PayjoinStateEmpty value)? empty,
    TResult? Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult? Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult? Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult? Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult? Function(PayjoinStateError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PayjoinStateEmpty value)? empty,
    TResult Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult Function(PayjoinStateError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PayjoinStateCopyWith<$Res> {
  factory $PayjoinStateCopyWith(
          PayjoinState value, $Res Function(PayjoinState) then) =
      _$PayjoinStateCopyWithImpl<$Res, PayjoinState>;
}

/// @nodoc
class _$PayjoinStateCopyWithImpl<$Res, $Val extends PayjoinState>
    implements $PayjoinStateCopyWith<$Res> {
  _$PayjoinStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PayjoinStateEmptyImplCopyWith<$Res> {
  factory _$$PayjoinStateEmptyImplCopyWith(_$PayjoinStateEmptyImpl value,
          $Res Function(_$PayjoinStateEmptyImpl) then) =
      __$$PayjoinStateEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PayjoinStateEmptyImplCopyWithImpl<$Res>
    extends _$PayjoinStateCopyWithImpl<$Res, _$PayjoinStateEmptyImpl>
    implements _$$PayjoinStateEmptyImplCopyWith<$Res> {
  __$$PayjoinStateEmptyImplCopyWithImpl(_$PayjoinStateEmptyImpl _value,
      $Res Function(_$PayjoinStateEmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PayjoinStateEmptyImpl implements PayjoinStateEmpty {
  const _$PayjoinStateEmptyImpl();

  @override
  String toString() {
    return 'PayjoinState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PayjoinStateEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(CreatePayjoin createPayjoin) createPayjoin,
    required TResult Function() waitingCreatedPayjoin,
    required TResult Function(CreatedPayjoin createdPayjoin) createdPayjoin,
    required TResult Function() waitingSendPayjoin,
    required TResult Function(String? errorMsg) error,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult? Function()? waitingCreatedPayjoin,
    TResult? Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult? Function()? waitingSendPayjoin,
    TResult? Function(String? errorMsg)? error,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult Function()? waitingCreatedPayjoin,
    TResult Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult Function()? waitingSendPayjoin,
    TResult Function(String? errorMsg)? error,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PayjoinStateEmpty value) empty,
    required TResult Function(PayjoinStateCreatePayjoin value) createPayjoin,
    required TResult Function(PayjoinStateWaitingCreatedPayjoin value)
        waitingCreatedPayjoin,
    required TResult Function(PayjoinStateCreatedPayjoin value) createdPayjoin,
    required TResult Function(PayjoinStateWaitingSendPayjoin value)
        waitingSendPayjoin,
    required TResult Function(PayjoinStateError value) error,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PayjoinStateEmpty value)? empty,
    TResult? Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult? Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult? Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult? Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult? Function(PayjoinStateError value)? error,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PayjoinStateEmpty value)? empty,
    TResult Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult Function(PayjoinStateError value)? error,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class PayjoinStateEmpty implements PayjoinState {
  const factory PayjoinStateEmpty() = _$PayjoinStateEmptyImpl;
}

/// @nodoc
abstract class _$$PayjoinStateCreatePayjoinImplCopyWith<$Res> {
  factory _$$PayjoinStateCreatePayjoinImplCopyWith(
          _$PayjoinStateCreatePayjoinImpl value,
          $Res Function(_$PayjoinStateCreatePayjoinImpl) then) =
      __$$PayjoinStateCreatePayjoinImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CreatePayjoin createPayjoin});
}

/// @nodoc
class __$$PayjoinStateCreatePayjoinImplCopyWithImpl<$Res>
    extends _$PayjoinStateCopyWithImpl<$Res, _$PayjoinStateCreatePayjoinImpl>
    implements _$$PayjoinStateCreatePayjoinImplCopyWith<$Res> {
  __$$PayjoinStateCreatePayjoinImplCopyWithImpl(
      _$PayjoinStateCreatePayjoinImpl _value,
      $Res Function(_$PayjoinStateCreatePayjoinImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? createPayjoin = null,
  }) {
    return _then(_$PayjoinStateCreatePayjoinImpl(
      null == createPayjoin
          ? _value.createPayjoin
          : createPayjoin // ignore: cast_nullable_to_non_nullable
              as CreatePayjoin,
    ));
  }
}

/// @nodoc

class _$PayjoinStateCreatePayjoinImpl implements PayjoinStateCreatePayjoin {
  const _$PayjoinStateCreatePayjoinImpl(this.createPayjoin);

  @override
  final CreatePayjoin createPayjoin;

  @override
  String toString() {
    return 'PayjoinState.createPayjoin(createPayjoin: $createPayjoin)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PayjoinStateCreatePayjoinImpl &&
            (identical(other.createPayjoin, createPayjoin) ||
                other.createPayjoin == createPayjoin));
  }

  @override
  int get hashCode => Object.hash(runtimeType, createPayjoin);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PayjoinStateCreatePayjoinImplCopyWith<_$PayjoinStateCreatePayjoinImpl>
      get copyWith => __$$PayjoinStateCreatePayjoinImplCopyWithImpl<
          _$PayjoinStateCreatePayjoinImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(CreatePayjoin createPayjoin) createPayjoin,
    required TResult Function() waitingCreatedPayjoin,
    required TResult Function(CreatedPayjoin createdPayjoin) createdPayjoin,
    required TResult Function() waitingSendPayjoin,
    required TResult Function(String? errorMsg) error,
  }) {
    return createPayjoin(this.createPayjoin);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult? Function()? waitingCreatedPayjoin,
    TResult? Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult? Function()? waitingSendPayjoin,
    TResult? Function(String? errorMsg)? error,
  }) {
    return createPayjoin?.call(this.createPayjoin);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult Function()? waitingCreatedPayjoin,
    TResult Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult Function()? waitingSendPayjoin,
    TResult Function(String? errorMsg)? error,
    required TResult orElse(),
  }) {
    if (createPayjoin != null) {
      return createPayjoin(this.createPayjoin);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PayjoinStateEmpty value) empty,
    required TResult Function(PayjoinStateCreatePayjoin value) createPayjoin,
    required TResult Function(PayjoinStateWaitingCreatedPayjoin value)
        waitingCreatedPayjoin,
    required TResult Function(PayjoinStateCreatedPayjoin value) createdPayjoin,
    required TResult Function(PayjoinStateWaitingSendPayjoin value)
        waitingSendPayjoin,
    required TResult Function(PayjoinStateError value) error,
  }) {
    return createPayjoin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PayjoinStateEmpty value)? empty,
    TResult? Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult? Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult? Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult? Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult? Function(PayjoinStateError value)? error,
  }) {
    return createPayjoin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PayjoinStateEmpty value)? empty,
    TResult Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult Function(PayjoinStateError value)? error,
    required TResult orElse(),
  }) {
    if (createPayjoin != null) {
      return createPayjoin(this);
    }
    return orElse();
  }
}

abstract class PayjoinStateCreatePayjoin implements PayjoinState {
  const factory PayjoinStateCreatePayjoin(final CreatePayjoin createPayjoin) =
      _$PayjoinStateCreatePayjoinImpl;

  CreatePayjoin get createPayjoin;
  @JsonKey(ignore: true)
  _$$PayjoinStateCreatePayjoinImplCopyWith<_$PayjoinStateCreatePayjoinImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PayjoinStateWaitingCreatedPayjoinImplCopyWith<$Res> {
  factory _$$PayjoinStateWaitingCreatedPayjoinImplCopyWith(
          _$PayjoinStateWaitingCreatedPayjoinImpl value,
          $Res Function(_$PayjoinStateWaitingCreatedPayjoinImpl) then) =
      __$$PayjoinStateWaitingCreatedPayjoinImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PayjoinStateWaitingCreatedPayjoinImplCopyWithImpl<$Res>
    extends _$PayjoinStateCopyWithImpl<$Res,
        _$PayjoinStateWaitingCreatedPayjoinImpl>
    implements _$$PayjoinStateWaitingCreatedPayjoinImplCopyWith<$Res> {
  __$$PayjoinStateWaitingCreatedPayjoinImplCopyWithImpl(
      _$PayjoinStateWaitingCreatedPayjoinImpl _value,
      $Res Function(_$PayjoinStateWaitingCreatedPayjoinImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PayjoinStateWaitingCreatedPayjoinImpl
    implements PayjoinStateWaitingCreatedPayjoin {
  const _$PayjoinStateWaitingCreatedPayjoinImpl();

  @override
  String toString() {
    return 'PayjoinState.waitingCreatedPayjoin()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PayjoinStateWaitingCreatedPayjoinImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(CreatePayjoin createPayjoin) createPayjoin,
    required TResult Function() waitingCreatedPayjoin,
    required TResult Function(CreatedPayjoin createdPayjoin) createdPayjoin,
    required TResult Function() waitingSendPayjoin,
    required TResult Function(String? errorMsg) error,
  }) {
    return waitingCreatedPayjoin();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult? Function()? waitingCreatedPayjoin,
    TResult? Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult? Function()? waitingSendPayjoin,
    TResult? Function(String? errorMsg)? error,
  }) {
    return waitingCreatedPayjoin?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult Function()? waitingCreatedPayjoin,
    TResult Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult Function()? waitingSendPayjoin,
    TResult Function(String? errorMsg)? error,
    required TResult orElse(),
  }) {
    if (waitingCreatedPayjoin != null) {
      return waitingCreatedPayjoin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PayjoinStateEmpty value) empty,
    required TResult Function(PayjoinStateCreatePayjoin value) createPayjoin,
    required TResult Function(PayjoinStateWaitingCreatedPayjoin value)
        waitingCreatedPayjoin,
    required TResult Function(PayjoinStateCreatedPayjoin value) createdPayjoin,
    required TResult Function(PayjoinStateWaitingSendPayjoin value)
        waitingSendPayjoin,
    required TResult Function(PayjoinStateError value) error,
  }) {
    return waitingCreatedPayjoin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PayjoinStateEmpty value)? empty,
    TResult? Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult? Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult? Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult? Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult? Function(PayjoinStateError value)? error,
  }) {
    return waitingCreatedPayjoin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PayjoinStateEmpty value)? empty,
    TResult Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult Function(PayjoinStateError value)? error,
    required TResult orElse(),
  }) {
    if (waitingCreatedPayjoin != null) {
      return waitingCreatedPayjoin(this);
    }
    return orElse();
  }
}

abstract class PayjoinStateWaitingCreatedPayjoin implements PayjoinState {
  const factory PayjoinStateWaitingCreatedPayjoin() =
      _$PayjoinStateWaitingCreatedPayjoinImpl;
}

/// @nodoc
abstract class _$$PayjoinStateCreatedPayjoinImplCopyWith<$Res> {
  factory _$$PayjoinStateCreatedPayjoinImplCopyWith(
          _$PayjoinStateCreatedPayjoinImpl value,
          $Res Function(_$PayjoinStateCreatedPayjoinImpl) then) =
      __$$PayjoinStateCreatedPayjoinImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CreatedPayjoin createdPayjoin});
}

/// @nodoc
class __$$PayjoinStateCreatedPayjoinImplCopyWithImpl<$Res>
    extends _$PayjoinStateCopyWithImpl<$Res, _$PayjoinStateCreatedPayjoinImpl>
    implements _$$PayjoinStateCreatedPayjoinImplCopyWith<$Res> {
  __$$PayjoinStateCreatedPayjoinImplCopyWithImpl(
      _$PayjoinStateCreatedPayjoinImpl _value,
      $Res Function(_$PayjoinStateCreatedPayjoinImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? createdPayjoin = null,
  }) {
    return _then(_$PayjoinStateCreatedPayjoinImpl(
      null == createdPayjoin
          ? _value.createdPayjoin
          : createdPayjoin // ignore: cast_nullable_to_non_nullable
              as CreatedPayjoin,
    ));
  }
}

/// @nodoc

class _$PayjoinStateCreatedPayjoinImpl implements PayjoinStateCreatedPayjoin {
  const _$PayjoinStateCreatedPayjoinImpl(this.createdPayjoin);

  @override
  final CreatedPayjoin createdPayjoin;

  @override
  String toString() {
    return 'PayjoinState.createdPayjoin(createdPayjoin: $createdPayjoin)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PayjoinStateCreatedPayjoinImpl &&
            (identical(other.createdPayjoin, createdPayjoin) ||
                other.createdPayjoin == createdPayjoin));
  }

  @override
  int get hashCode => Object.hash(runtimeType, createdPayjoin);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PayjoinStateCreatedPayjoinImplCopyWith<_$PayjoinStateCreatedPayjoinImpl>
      get copyWith => __$$PayjoinStateCreatedPayjoinImplCopyWithImpl<
          _$PayjoinStateCreatedPayjoinImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(CreatePayjoin createPayjoin) createPayjoin,
    required TResult Function() waitingCreatedPayjoin,
    required TResult Function(CreatedPayjoin createdPayjoin) createdPayjoin,
    required TResult Function() waitingSendPayjoin,
    required TResult Function(String? errorMsg) error,
  }) {
    return createdPayjoin(this.createdPayjoin);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult? Function()? waitingCreatedPayjoin,
    TResult? Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult? Function()? waitingSendPayjoin,
    TResult? Function(String? errorMsg)? error,
  }) {
    return createdPayjoin?.call(this.createdPayjoin);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult Function()? waitingCreatedPayjoin,
    TResult Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult Function()? waitingSendPayjoin,
    TResult Function(String? errorMsg)? error,
    required TResult orElse(),
  }) {
    if (createdPayjoin != null) {
      return createdPayjoin(this.createdPayjoin);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PayjoinStateEmpty value) empty,
    required TResult Function(PayjoinStateCreatePayjoin value) createPayjoin,
    required TResult Function(PayjoinStateWaitingCreatedPayjoin value)
        waitingCreatedPayjoin,
    required TResult Function(PayjoinStateCreatedPayjoin value) createdPayjoin,
    required TResult Function(PayjoinStateWaitingSendPayjoin value)
        waitingSendPayjoin,
    required TResult Function(PayjoinStateError value) error,
  }) {
    return createdPayjoin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PayjoinStateEmpty value)? empty,
    TResult? Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult? Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult? Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult? Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult? Function(PayjoinStateError value)? error,
  }) {
    return createdPayjoin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PayjoinStateEmpty value)? empty,
    TResult Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult Function(PayjoinStateError value)? error,
    required TResult orElse(),
  }) {
    if (createdPayjoin != null) {
      return createdPayjoin(this);
    }
    return orElse();
  }
}

abstract class PayjoinStateCreatedPayjoin implements PayjoinState {
  const factory PayjoinStateCreatedPayjoin(
      final CreatedPayjoin createdPayjoin) = _$PayjoinStateCreatedPayjoinImpl;

  CreatedPayjoin get createdPayjoin;
  @JsonKey(ignore: true)
  _$$PayjoinStateCreatedPayjoinImplCopyWith<_$PayjoinStateCreatedPayjoinImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PayjoinStateWaitingSendPayjoinImplCopyWith<$Res> {
  factory _$$PayjoinStateWaitingSendPayjoinImplCopyWith(
          _$PayjoinStateWaitingSendPayjoinImpl value,
          $Res Function(_$PayjoinStateWaitingSendPayjoinImpl) then) =
      __$$PayjoinStateWaitingSendPayjoinImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PayjoinStateWaitingSendPayjoinImplCopyWithImpl<$Res>
    extends _$PayjoinStateCopyWithImpl<$Res,
        _$PayjoinStateWaitingSendPayjoinImpl>
    implements _$$PayjoinStateWaitingSendPayjoinImplCopyWith<$Res> {
  __$$PayjoinStateWaitingSendPayjoinImplCopyWithImpl(
      _$PayjoinStateWaitingSendPayjoinImpl _value,
      $Res Function(_$PayjoinStateWaitingSendPayjoinImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PayjoinStateWaitingSendPayjoinImpl
    implements PayjoinStateWaitingSendPayjoin {
  const _$PayjoinStateWaitingSendPayjoinImpl();

  @override
  String toString() {
    return 'PayjoinState.waitingSendPayjoin()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PayjoinStateWaitingSendPayjoinImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(CreatePayjoin createPayjoin) createPayjoin,
    required TResult Function() waitingCreatedPayjoin,
    required TResult Function(CreatedPayjoin createdPayjoin) createdPayjoin,
    required TResult Function() waitingSendPayjoin,
    required TResult Function(String? errorMsg) error,
  }) {
    return waitingSendPayjoin();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult? Function()? waitingCreatedPayjoin,
    TResult? Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult? Function()? waitingSendPayjoin,
    TResult? Function(String? errorMsg)? error,
  }) {
    return waitingSendPayjoin?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult Function()? waitingCreatedPayjoin,
    TResult Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult Function()? waitingSendPayjoin,
    TResult Function(String? errorMsg)? error,
    required TResult orElse(),
  }) {
    if (waitingSendPayjoin != null) {
      return waitingSendPayjoin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PayjoinStateEmpty value) empty,
    required TResult Function(PayjoinStateCreatePayjoin value) createPayjoin,
    required TResult Function(PayjoinStateWaitingCreatedPayjoin value)
        waitingCreatedPayjoin,
    required TResult Function(PayjoinStateCreatedPayjoin value) createdPayjoin,
    required TResult Function(PayjoinStateWaitingSendPayjoin value)
        waitingSendPayjoin,
    required TResult Function(PayjoinStateError value) error,
  }) {
    return waitingSendPayjoin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PayjoinStateEmpty value)? empty,
    TResult? Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult? Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult? Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult? Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult? Function(PayjoinStateError value)? error,
  }) {
    return waitingSendPayjoin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PayjoinStateEmpty value)? empty,
    TResult Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult Function(PayjoinStateError value)? error,
    required TResult orElse(),
  }) {
    if (waitingSendPayjoin != null) {
      return waitingSendPayjoin(this);
    }
    return orElse();
  }
}

abstract class PayjoinStateWaitingSendPayjoin implements PayjoinState {
  const factory PayjoinStateWaitingSendPayjoin() =
      _$PayjoinStateWaitingSendPayjoinImpl;
}

/// @nodoc
abstract class _$$PayjoinStateErrorImplCopyWith<$Res> {
  factory _$$PayjoinStateErrorImplCopyWith(_$PayjoinStateErrorImpl value,
          $Res Function(_$PayjoinStateErrorImpl) then) =
      __$$PayjoinStateErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? errorMsg});
}

/// @nodoc
class __$$PayjoinStateErrorImplCopyWithImpl<$Res>
    extends _$PayjoinStateCopyWithImpl<$Res, _$PayjoinStateErrorImpl>
    implements _$$PayjoinStateErrorImplCopyWith<$Res> {
  __$$PayjoinStateErrorImplCopyWithImpl(_$PayjoinStateErrorImpl _value,
      $Res Function(_$PayjoinStateErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMsg = freezed,
  }) {
    return _then(_$PayjoinStateErrorImpl(
      freezed == errorMsg
          ? _value.errorMsg
          : errorMsg // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$PayjoinStateErrorImpl implements PayjoinStateError {
  const _$PayjoinStateErrorImpl([this.errorMsg]);

  @override
  final String? errorMsg;

  @override
  String toString() {
    return 'PayjoinState.error(errorMsg: $errorMsg)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PayjoinStateErrorImpl &&
            (identical(other.errorMsg, errorMsg) ||
                other.errorMsg == errorMsg));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMsg);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PayjoinStateErrorImplCopyWith<_$PayjoinStateErrorImpl> get copyWith =>
      __$$PayjoinStateErrorImplCopyWithImpl<_$PayjoinStateErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(CreatePayjoin createPayjoin) createPayjoin,
    required TResult Function() waitingCreatedPayjoin,
    required TResult Function(CreatedPayjoin createdPayjoin) createdPayjoin,
    required TResult Function() waitingSendPayjoin,
    required TResult Function(String? errorMsg) error,
  }) {
    return error(errorMsg);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult? Function()? waitingCreatedPayjoin,
    TResult? Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult? Function()? waitingSendPayjoin,
    TResult? Function(String? errorMsg)? error,
  }) {
    return error?.call(errorMsg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(CreatePayjoin createPayjoin)? createPayjoin,
    TResult Function()? waitingCreatedPayjoin,
    TResult Function(CreatedPayjoin createdPayjoin)? createdPayjoin,
    TResult Function()? waitingSendPayjoin,
    TResult Function(String? errorMsg)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(errorMsg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PayjoinStateEmpty value) empty,
    required TResult Function(PayjoinStateCreatePayjoin value) createPayjoin,
    required TResult Function(PayjoinStateWaitingCreatedPayjoin value)
        waitingCreatedPayjoin,
    required TResult Function(PayjoinStateCreatedPayjoin value) createdPayjoin,
    required TResult Function(PayjoinStateWaitingSendPayjoin value)
        waitingSendPayjoin,
    required TResult Function(PayjoinStateError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PayjoinStateEmpty value)? empty,
    TResult? Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult? Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult? Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult? Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult? Function(PayjoinStateError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PayjoinStateEmpty value)? empty,
    TResult Function(PayjoinStateCreatePayjoin value)? createPayjoin,
    TResult Function(PayjoinStateWaitingCreatedPayjoin value)?
        waitingCreatedPayjoin,
    TResult Function(PayjoinStateCreatedPayjoin value)? createdPayjoin,
    TResult Function(PayjoinStateWaitingSendPayjoin value)? waitingSendPayjoin,
    TResult Function(PayjoinStateError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PayjoinStateError implements PayjoinState {
  const factory PayjoinStateError([final String? errorMsg]) =
      _$PayjoinStateErrorImpl;

  String? get errorMsg;
  @JsonKey(ignore: true)
  _$$PayjoinStateErrorImplCopyWith<_$PayjoinStateErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
