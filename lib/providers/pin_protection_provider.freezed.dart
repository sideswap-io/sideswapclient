// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'pin_protection_provider.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$PinUnlockState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function() wrong,
    required TResult Function() failed,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function()? wrong,
    TResult? Function()? failed,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function()? wrong,
    TResult Function()? failed,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinUnlockStateEmpty value) empty,
    required TResult Function(PinUnlockStateSuccess value) success,
    required TResult Function(PinUnlockStateWrong value) wrong,
    required TResult Function(PinUnlockStateFailed value) failed,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinUnlockStateEmpty value)? empty,
    TResult? Function(PinUnlockStateSuccess value)? success,
    TResult? Function(PinUnlockStateWrong value)? wrong,
    TResult? Function(PinUnlockStateFailed value)? failed,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinUnlockStateEmpty value)? empty,
    TResult Function(PinUnlockStateSuccess value)? success,
    TResult Function(PinUnlockStateWrong value)? wrong,
    TResult Function(PinUnlockStateFailed value)? failed,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PinUnlockStateCopyWith<$Res> {
  factory $PinUnlockStateCopyWith(
    PinUnlockState value,
    $Res Function(PinUnlockState) then,
  ) = _$PinUnlockStateCopyWithImpl<$Res, PinUnlockState>;
}

/// @nodoc
class _$PinUnlockStateCopyWithImpl<$Res, $Val extends PinUnlockState>
    implements $PinUnlockStateCopyWith<$Res> {
  _$PinUnlockStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PinUnlockState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$PinUnlockStateEmptyImplCopyWith<$Res> {
  factory _$$PinUnlockStateEmptyImplCopyWith(
    _$PinUnlockStateEmptyImpl value,
    $Res Function(_$PinUnlockStateEmptyImpl) then,
  ) = __$$PinUnlockStateEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinUnlockStateEmptyImplCopyWithImpl<$Res>
    extends _$PinUnlockStateCopyWithImpl<$Res, _$PinUnlockStateEmptyImpl>
    implements _$$PinUnlockStateEmptyImplCopyWith<$Res> {
  __$$PinUnlockStateEmptyImplCopyWithImpl(
    _$PinUnlockStateEmptyImpl _value,
    $Res Function(_$PinUnlockStateEmptyImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PinUnlockState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PinUnlockStateEmptyImpl implements PinUnlockStateEmpty {
  const _$PinUnlockStateEmptyImpl();

  @override
  String toString() {
    return 'PinUnlockState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinUnlockStateEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function() wrong,
    required TResult Function() failed,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function()? wrong,
    TResult? Function()? failed,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function()? wrong,
    TResult Function()? failed,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinUnlockStateEmpty value) empty,
    required TResult Function(PinUnlockStateSuccess value) success,
    required TResult Function(PinUnlockStateWrong value) wrong,
    required TResult Function(PinUnlockStateFailed value) failed,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinUnlockStateEmpty value)? empty,
    TResult? Function(PinUnlockStateSuccess value)? success,
    TResult? Function(PinUnlockStateWrong value)? wrong,
    TResult? Function(PinUnlockStateFailed value)? failed,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinUnlockStateEmpty value)? empty,
    TResult Function(PinUnlockStateSuccess value)? success,
    TResult Function(PinUnlockStateWrong value)? wrong,
    TResult Function(PinUnlockStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class PinUnlockStateEmpty implements PinUnlockState {
  const factory PinUnlockStateEmpty() = _$PinUnlockStateEmptyImpl;
}

/// @nodoc
abstract class _$$PinUnlockStateSuccessImplCopyWith<$Res> {
  factory _$$PinUnlockStateSuccessImplCopyWith(
    _$PinUnlockStateSuccessImpl value,
    $Res Function(_$PinUnlockStateSuccessImpl) then,
  ) = __$$PinUnlockStateSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinUnlockStateSuccessImplCopyWithImpl<$Res>
    extends _$PinUnlockStateCopyWithImpl<$Res, _$PinUnlockStateSuccessImpl>
    implements _$$PinUnlockStateSuccessImplCopyWith<$Res> {
  __$$PinUnlockStateSuccessImplCopyWithImpl(
    _$PinUnlockStateSuccessImpl _value,
    $Res Function(_$PinUnlockStateSuccessImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PinUnlockState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PinUnlockStateSuccessImpl implements PinUnlockStateSuccess {
  const _$PinUnlockStateSuccessImpl();

  @override
  String toString() {
    return 'PinUnlockState.success()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinUnlockStateSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function() wrong,
    required TResult Function() failed,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function()? wrong,
    TResult? Function()? failed,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function()? wrong,
    TResult Function()? failed,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinUnlockStateEmpty value) empty,
    required TResult Function(PinUnlockStateSuccess value) success,
    required TResult Function(PinUnlockStateWrong value) wrong,
    required TResult Function(PinUnlockStateFailed value) failed,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinUnlockStateEmpty value)? empty,
    TResult? Function(PinUnlockStateSuccess value)? success,
    TResult? Function(PinUnlockStateWrong value)? wrong,
    TResult? Function(PinUnlockStateFailed value)? failed,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinUnlockStateEmpty value)? empty,
    TResult Function(PinUnlockStateSuccess value)? success,
    TResult Function(PinUnlockStateWrong value)? wrong,
    TResult Function(PinUnlockStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class PinUnlockStateSuccess implements PinUnlockState {
  const factory PinUnlockStateSuccess() = _$PinUnlockStateSuccessImpl;
}

/// @nodoc
abstract class _$$PinUnlockStateWrongImplCopyWith<$Res> {
  factory _$$PinUnlockStateWrongImplCopyWith(
    _$PinUnlockStateWrongImpl value,
    $Res Function(_$PinUnlockStateWrongImpl) then,
  ) = __$$PinUnlockStateWrongImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinUnlockStateWrongImplCopyWithImpl<$Res>
    extends _$PinUnlockStateCopyWithImpl<$Res, _$PinUnlockStateWrongImpl>
    implements _$$PinUnlockStateWrongImplCopyWith<$Res> {
  __$$PinUnlockStateWrongImplCopyWithImpl(
    _$PinUnlockStateWrongImpl _value,
    $Res Function(_$PinUnlockStateWrongImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PinUnlockState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PinUnlockStateWrongImpl implements PinUnlockStateWrong {
  const _$PinUnlockStateWrongImpl();

  @override
  String toString() {
    return 'PinUnlockState.wrong()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinUnlockStateWrongImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function() wrong,
    required TResult Function() failed,
  }) {
    return wrong();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function()? wrong,
    TResult? Function()? failed,
  }) {
    return wrong?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function()? wrong,
    TResult Function()? failed,
    required TResult orElse(),
  }) {
    if (wrong != null) {
      return wrong();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinUnlockStateEmpty value) empty,
    required TResult Function(PinUnlockStateSuccess value) success,
    required TResult Function(PinUnlockStateWrong value) wrong,
    required TResult Function(PinUnlockStateFailed value) failed,
  }) {
    return wrong(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinUnlockStateEmpty value)? empty,
    TResult? Function(PinUnlockStateSuccess value)? success,
    TResult? Function(PinUnlockStateWrong value)? wrong,
    TResult? Function(PinUnlockStateFailed value)? failed,
  }) {
    return wrong?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinUnlockStateEmpty value)? empty,
    TResult Function(PinUnlockStateSuccess value)? success,
    TResult Function(PinUnlockStateWrong value)? wrong,
    TResult Function(PinUnlockStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (wrong != null) {
      return wrong(this);
    }
    return orElse();
  }
}

abstract class PinUnlockStateWrong implements PinUnlockState {
  const factory PinUnlockStateWrong() = _$PinUnlockStateWrongImpl;
}

/// @nodoc
abstract class _$$PinUnlockStateFailedImplCopyWith<$Res> {
  factory _$$PinUnlockStateFailedImplCopyWith(
    _$PinUnlockStateFailedImpl value,
    $Res Function(_$PinUnlockStateFailedImpl) then,
  ) = __$$PinUnlockStateFailedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PinUnlockStateFailedImplCopyWithImpl<$Res>
    extends _$PinUnlockStateCopyWithImpl<$Res, _$PinUnlockStateFailedImpl>
    implements _$$PinUnlockStateFailedImplCopyWith<$Res> {
  __$$PinUnlockStateFailedImplCopyWithImpl(
    _$PinUnlockStateFailedImpl _value,
    $Res Function(_$PinUnlockStateFailedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PinUnlockState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PinUnlockStateFailedImpl implements PinUnlockStateFailed {
  const _$PinUnlockStateFailedImpl();

  @override
  String toString() {
    return 'PinUnlockState.failed()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PinUnlockStateFailedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() success,
    required TResult Function() wrong,
    required TResult Function() failed,
  }) {
    return failed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function()? success,
    TResult? Function()? wrong,
    TResult? Function()? failed,
  }) {
    return failed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? success,
    TResult Function()? wrong,
    TResult Function()? failed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PinUnlockStateEmpty value) empty,
    required TResult Function(PinUnlockStateSuccess value) success,
    required TResult Function(PinUnlockStateWrong value) wrong,
    required TResult Function(PinUnlockStateFailed value) failed,
  }) {
    return failed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PinUnlockStateEmpty value)? empty,
    TResult? Function(PinUnlockStateSuccess value)? success,
    TResult? Function(PinUnlockStateWrong value)? wrong,
    TResult? Function(PinUnlockStateFailed value)? failed,
  }) {
    return failed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PinUnlockStateEmpty value)? empty,
    TResult Function(PinUnlockStateSuccess value)? success,
    TResult Function(PinUnlockStateWrong value)? wrong,
    TResult Function(PinUnlockStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(this);
    }
    return orElse();
  }
}

abstract class PinUnlockStateFailed implements PinUnlockState {
  const factory PinUnlockStateFailed() = _$PinUnlockStateFailedImpl;
}
